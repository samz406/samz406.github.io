<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.sanmuzi.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="在《整洁架构之道》的第四部分，Robert C. Martin（Uncle Bob）探讨了架构的设计原则。并提出了整洁架构">
<meta property="og:type" content="article">
<meta property="og:title" content="整洁架构之道之架构篇">
<meta property="og:url" content="http://www.sanmuzi.com/2025/03/17/Clean-Architecture-architecture/index.html">
<meta property="og:site_name" content="一子三木">
<meta property="og:description" content="在《整洁架构之道》的第四部分，Robert C. Martin（Uncle Bob）探讨了架构的设计原则。并提出了整洁架构">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-03-17T12:00:56.000Z">
<meta property="article:modified_time" content="2025-08-15T12:01:09.331Z">
<meta property="article:author" content="爱妙妙爱生活">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.sanmuzi.com/2025/03/17/Clean-Architecture-architecture/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>整洁架构之道之架构篇 | 一子三木</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">一子三木</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">所看 所学 所思</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.sanmuzi.com/2025/03/17/Clean-Architecture-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="爱妙妙爱生活">
      <meta itemprop="description" content="日拱一卒，功不唐捐">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="一子三木">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          整洁架构之道之架构篇
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-17 20:00:56" itemprop="dateCreated datePublished" datetime="2025-03-17T20:00:56+08:00">2025-03-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在《整洁架构之道》的第四部分，Robert C. Martin（Uncle Bob）探讨了架构的设计原则。并提出了整洁架构</p>
<span id="more"></span>

<h3 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h3><h5 id="传统的误解"><a href="#传统的误解" class="headerlink" title="传统的误解"></a><strong>传统的误解</strong></h5><p>很多开发者认为：</p>
<ul>
<li>架构就是框架（Framework），选择 Spring Boot、Django 或者 Express.js。但 Unlce Bob 认为，这只是<strong>技术实现的细节</strong>，而不是真正的架构。</li>
<li>架构就是模式（Design Patterns），例如 MVC、MVVM、微服务（Microservices）。但这些都是具体的设计方案，而不是真正的架构思想。</li>
<li>架构是代码组织方式，例如，分层架构（Controller → Service → Repository）。但这只是架构的一部分，真正的架构涉及更多的原则和决策。</li>
</ul>
<h5 id="正确的定义"><a href="#正确的定义" class="headerlink" title="正确的定义"></a><strong>正确的定义</strong></h5><p><strong>架构的核心目标是降低软件的开发和维护成本，使得系统更容易扩展、修改和理解</strong>。架构关注的不是<strong>代码如何运行</strong>，而是<strong>代码如何演进</strong>。</p>
<blockquote>
<p><strong>“架构的终极目标是保持软件的灵活性，确保系统能适应未来的需求变化，而不会导致高昂的修改成本。”</strong></p>
</blockquote>
<h4 id="架构的核心目标"><a href="#架构的核心目标" class="headerlink" title="架构的核心目标"></a><strong>架构的核心目标</strong></h4><h5 id="架构是关于“保持选项开放”（Keeping-Options-Open）"><a href="#架构是关于“保持选项开放”（Keeping-Options-Open）" class="headerlink" title="架构是关于“保持选项开放”（Keeping Options Open）"></a><strong>架构是关于“保持选项开放”（Keeping Options Open）</strong></h5><ul>
<li><strong>架构的最大价值在于减少对具体技术的依赖</strong>，确保未来的变更不会破坏整个系统。</li>
<li>例如：<ul>
<li><strong>错误的做法</strong>：业务逻辑直接依赖数据库 API（如 SQL 语句）。</li>
<li><strong>正确的做法</strong>：业务逻辑使用 <code>Repository</code> 模式，数据库可以随时更换。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 业务逻辑直接依赖 MySQL</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://...&quot;</span>);</span><br><span class="line">        PreparedStatement stmt = conn.prepareStatement(<span class="string">&quot;INSERT INTO orders...&quot;</span>);</span><br><span class="line">        stmt.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：如果以后要换成 MongoDB，就必须修改所有相关的代码。</p>
<p><strong>改进版本（架构更灵活）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(OrderRepository orderRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样：</p>
<ul>
<li>未来更换数据库时，只需要修改 <code>OrderRepository</code> 的实现，而不需要改动 <code>OrderService</code>。</li>
<li>业务逻辑不会被数据库实现“绑架”，系统的灵活性更高。</li>
</ul>
<hr>
<h5 id="架构应该“推迟技术决策”"><a href="#架构应该“推迟技术决策”" class="headerlink" title="架构应该“推迟技术决策”"></a><strong>架构应该“推迟技术决策”</strong></h5><ul>
<li>很多开发者在项目早期就决定了数据库、Web 框架、前端技术。<strong>真正的架构应该推迟这些决策</strong>，先关注业务逻辑。</li>
</ul>
<blockquote>
<p><strong>“你应该能够在不修改业务逻辑的情况下，更换数据库、UI、Web 框架等技术栈。”</strong></p>
</blockquote>
<h5 id="架构是关于“分离关注点”（Separation-of-Concerns）"><a href="#架构是关于“分离关注点”（Separation-of-Concerns）" class="headerlink" title="架构是关于“分离关注点”（Separation of Concerns）"></a><strong>架构是关于“分离关注点”（Separation of Concerns）</strong></h5><p>软件系统应该被拆分成多个 <strong>独立的、可测试的部分</strong>，每个部分都有清晰的职责。例如：<strong>业务逻辑（Use Cases）</strong> 只处理核心业务，不关心 UI、数据库或外部 API。数据访问层（Repository） 只负责存储和读取数据，不关心业务逻辑。UI 层 只负责展示数据，不直接与数据库交互。</p>
<p>这与整洁架构的核心思想一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Entities] ← [Use Cases] ← [Interface Adapters] ← [Frameworks &amp; Drivers]</span><br></pre></td></tr></table></figure>

<ul>
<li>业务逻辑永远不会直接依赖外部框架，而是通过<strong>接口</strong>与外界交互。</li>
</ul>
<h4 id="架构-vs-详细设计"><a href="#架构-vs-详细设计" class="headerlink" title="架构 vs. 详细设计"></a>架构 vs. 详细设计</h4><table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>架构（Architecture）</strong></th>
<th><strong>详细设计（Detailed Design）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>关注点</strong></td>
<td>代码如何组织，如何变化</td>
<td>代码的具体实现</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>整个系统的结构</td>
<td>具体模块或类</td>
</tr>
<tr>
<td><strong>决定因素</strong></td>
<td>灵活性、可扩展性、可维护性</td>
<td>代码的可读性、性能</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>分层架构、依赖倒置原则</td>
<td>设计模式（如工厂模式、观察者模式）</td>
</tr>
</tbody></table>
<hr>
<h4 id="现实世界的架构决策"><a href="#现实世界的架构决策" class="headerlink" title="现实世界的架构决策"></a>现实世界的架构决策</h4><h5 id="案例-1：错误的架构选择"><a href="#案例-1：错误的架构选择" class="headerlink" title="案例 1：错误的架构选择"></a><strong>案例 1：错误的架构选择</strong></h5><p>在某些项目中，团队可能会在一开始就绑定特定的框架，例如：</p>
<ul>
<li>直接在 <code>Spring Controller</code> 里写 SQL 查询：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;INSERT INTO orders VALUES ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：</p>
<ul>
<li>业务逻辑与 Spring 和 MySQL 紧密耦合，未来很难迁移到其他技术。</li>
</ul>
<p><strong>更好的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderController</span><span class="params">(PlaceOrderUseCase placeOrderUseCase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.placeOrderUseCase = placeOrderUseCase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样，<code>OrderController</code> 只处理 HTTP 请求，<code>PlaceOrderUseCase</code> 处理业务逻辑，而数据存储交给 <code>Repository</code> 层。</li>
<li>如果未来要换数据库，只需要修改 <code>Repository</code>，不会影响 Controller 和 Use Case。</li>
</ul>
<h3 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h3><ul>
<li><strong>业务逻辑应该独立于框架、数据库、UI 和外部服务。</strong></li>
<li><strong>使用“依赖倒置”让业务逻辑依赖抽象，而不是具体实现。</strong></li>
<li><strong>真正的架构不是选择技术，而是确保技术可以随时更换，而不影响核心业务逻辑！</strong></li>
</ul>
<h5 id="么是“独立性”？"><a href="#么是“独立性”？" class="headerlink" title="么是“独立性”？"></a><strong>么是“独立性”？</strong></h5><p><strong>“独立性”指的是系统的不同部分应该尽可能减少对外部技术、框架、库的依赖，以保持业务逻辑的纯粹性。</strong></p>
<blockquote>
<p><strong>“架构的核心目标是保持软件的独立性，使得业务逻辑不依赖于框架、数据库、UI 或外部服务。”</strong></p>
</blockquote>
<h3 id="常见的软件依赖"><a href="#常见的软件依赖" class="headerlink" title="常见的软件依赖"></a><strong>常见的软件依赖</strong></h3><p>在软件开发中，系统通常依赖以下几个方面：</p>
<ol>
<li>框架（Frameworks）<ul>
<li>例如，Spring、Django、React、Angular。</li>
<li>这些框架通常会强加自己的架构模式，导致系统高度依赖框架，难以替换。</li>
</ul>
</li>
<li>UI（User Interface）<ul>
<li>例如，Web 前端、移动端应用（Android/iOS）。</li>
<li>如果业务逻辑直接依赖 UI 组件，未来更换 UI 技术将变得困难。</li>
</ul>
</li>
<li>数据库（Database）<ul>
<li>例如，MySQL、MongoDB、PostgreSQL。</li>
<li>如果业务逻辑直接依赖数据库查询语句（SQL），将难以迁移到新的数据库系统。</li>
</ul>
</li>
<li>外部服务（External Services）<ul>
<li>例如，支付网关、消息队列、云存储。</li>
<li>直接依赖这些服务的 API 可能导致供应商锁定（Vendor Lock-in）。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-为什么独立性重要？"><a href="#2-为什么独立性重要？" class="headerlink" title="2. 为什么独立性重要？"></a><strong>2. 为什么独立性重要？</strong></h5><h3 id="（1）让软件更容易修改"><a href="#（1）让软件更容易修改" class="headerlink" title="（1）让软件更容易修改"></a><strong>（1）让软件更容易修改</strong></h3><ul>
<li><p>如果业务逻辑<strong>不依赖</strong>数据库或 UI，未来即使更换数据库或 UI，也不需要改动核心代码。</p>
</li>
<li><p><strong>示例：错误的做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate; <span class="comment">// 直接依赖数据库</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;INSERT INTO orders VALUES ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里 <code>OrderService</code> 直接依赖 MySQL 的 <code>JdbcTemplate</code>，如果未来更换数据库，就必须修改 <code>OrderService</code>。</li>
</ul>
</li>
<li><p><strong>正确的做法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository; <span class="comment">// 依赖抽象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(OrderRepository orderRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderRepository.save(order); <span class="comment">// 业务逻辑不依赖数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，<code>OrderRepository</code> 可以有不同的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123; jdbcTemplate.update(<span class="string">&quot;INSERT INTO orders VALUES ...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDBOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123; mongoTemplate.save(order, <span class="string">&quot;orders&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样，我们可以在不修改 <code>OrderService</code> 的情况下自由更换数据库。</li>
</ul>
</li>
</ul>
<h3 id="（2）提高可测试性"><a href="#（2）提高可测试性" class="headerlink" title="（2）提高可测试性"></a><strong>（2）提高可测试性</strong></h3><ul>
<li><p>如果业务逻辑依赖数据库或外部 API，测试时就需要连接这些外部系统，导致测试变慢、不稳定。</p>
</li>
<li><p><strong>解决方案</strong>：使用 <strong>依赖倒置（Dependency Inversion）</strong>，让业务逻辑依赖抽象接口，而不是具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderRepository mockRepo = mock(OrderRepository.class);</span><br><span class="line">        OrderService orderService = <span class="keyword">new</span> OrderService(mockRepo);</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        orderService.saveOrder(order);</span><br><span class="line"></span><br><span class="line">        verify(mockRepo).save(order); <span class="comment">// 断言 OrderRepository 被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 <code>OrderService</code> 依赖抽象 <code>OrderRepository</code>，我们可以在测试时<strong>使用 Mock</strong>，避免真实数据库依赖。</li>
</ul>
</li>
</ul>
<h3 id="（3）避免技术锁定（Vendor-Lock-in）"><a href="#（3）避免技术锁定（Vendor-Lock-in）" class="headerlink" title="（3）避免技术锁定（Vendor Lock-in）"></a><strong>（3）避免技术锁定（Vendor Lock-in）</strong></h3><ul>
<li><p>许多公司一开始选择某个云服务或数据库，几年后发现成本过高或功能受限，但因为系统已经<strong>高度依赖</strong>该技术，迁移代价极高。</p>
</li>
<li><p>解决方案</p>
<p>：</p>
<ul>
<li><strong>封装外部服务的 API</strong>，让业务逻辑只依赖抽象接口，而不是直接调用 SDK 或 API。</li>
<li>这样，如果未来更换供应商，只需要修改 API 适配层，而不是整个业务逻辑。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-如何实现“独立性”？"><a href="#3-如何实现“独立性”？" class="headerlink" title="3. 如何实现“独立性”？"></a><strong>3. 如何实现“独立性”？</strong></h2><h3 id="（1）独立于框架"><a href="#（1）独立于框架" class="headerlink" title="（1）独立于框架"></a><strong>（1）独立于框架</strong></h3><ul>
<li><p><strong>错误的做法</strong>：让业务逻辑直接依赖框架组件，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里 <code>OrderService</code> 依赖了 <code>@Service</code> 和 <code>@Autowired</code>，这使得它<strong>只能在 Spring 运行</strong>，无法在普通 Java 代码或单元测试中运行。</li>
</ul>
</li>
<li><p><strong>正确的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(OrderRepository orderRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样 <code>OrderService</code> <strong>不依赖 Spring</strong>，可以独立测试，也可以用于不同的环境（如命令行应用、Android 应用）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="（2）独立于-UI"><a href="#（2）独立于-UI" class="headerlink" title="（2）独立于 UI"></a><strong>（2）独立于 UI</strong></h3><ul>
<li><p>UI 层应该只是一个<strong>适配器（Adapter）</strong>，不应该包含业务逻辑。</p>
</li>
<li><p><strong>错误的做法</strong>：在前端或 Controller 里编写业务逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (order.getItems().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.badRequest().body(<span class="string">&quot;订单不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        order.calculateTotal();</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Order placed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这里 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Controller</span><br></pre></td></tr></table></figure>

<p> 里包含了 </p>
<p>业务逻辑</p>
<p>（订单不能为空、计算总价），这会导致：</p>
<ul>
<li>未来如果 UI 变更（比如从 Web 迁移到 Mobile），这些逻辑必须重新实现。</li>
<li>无法在没有 Web 服务器的情况下测试业务逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>正确的做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderController</span><span class="params">(PlaceOrderUseCase placeOrderUseCase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.placeOrderUseCase = placeOrderUseCase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Order placed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Controller</code> 只是调用 <code>Use Case</code>，所有业务逻辑都在 <code>PlaceOrderUseCase</code> 中，UI 变化不会影响业务逻辑。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-个人理解"><a href="#4-个人理解" class="headerlink" title="4. 个人理解"></a><strong>4. 个人理解</strong></h2><ul>
<li><p><strong>“独立性”是架构的核心目标之一</strong>，如果业务逻辑与数据库、UI、框架耦合，维护成本会大大增加。</p>
</li>
<li><p>最好的架构是可以在不影响业务逻辑的情况下更换技术栈</p>
<p>，比如：</p>
<ul>
<li>更换数据库时，不影响业务逻辑。</li>
<li>更换 UI（Web → Mobile）时，不影响后端核心逻辑。</li>
</ul>
</li>
<li><p><strong>避免“过早绑定”技术</strong>，推迟技术决策，让系统有更大的灵活性。</p>
</li>
</ul>
<h3 id="边界——如何划分"><a href="#边界——如何划分" class="headerlink" title="边界——如何划分"></a>边界——如何划分</h3><p>在 <em>Clean Architecture</em> 的第 17 章，Uncle Bob 讨论了<strong>“边界”</strong>（Boundaries）的概念，以及如何在软件架构中合理划分边界，使得系统既能保持灵活性，又能降低维护成本。</p>
<p>这一章的核心观点包括：</p>
<ol>
<li><strong>边界（Boundaries）是软件架构的核心，它决定了系统的模块化程度和可维护性。</strong></li>
<li><strong>良好的边界划分可以减少耦合，提高独立性，使得不同模块可以独立开发、测试和部署。</strong></li>
<li><strong>不清晰的边界会导致系统复杂化，使得代码变得难以理解和修改。</strong></li>
</ol>
<hr>
<h5 id="什么是“边界”？"><a href="#什么是“边界”？" class="headerlink" title="** 什么是“边界”？**"></a>** 什么是“边界”？**</h5><p><strong>边界（Boundaries）指的是不同模块之间的分隔线，决定了系统如何拆分、组织和交互。</strong></p>
<p>在软件架构中，边界通常用于<strong>隔离不同的关注点</strong>，比如：</p>
<ul>
<li><strong>业务逻辑 vs. 数据存储</strong></li>
<li><strong>UI vs. 后端服务</strong></li>
<li><strong>不同微服务之间的交互</strong></li>
</ul>
<h3 id="现实世界的类比"><a href="#现实世界的类比" class="headerlink" title="现实世界的类比"></a><strong>现实世界的类比</strong></h3><p>想象一下<strong>边界就像不同国家的国界线</strong>：</p>
<ul>
<li><strong>如果边界清晰</strong>，每个国家都可以独立管理自己的法律、经济、文化，不会相互干涉。</li>
<li><strong>如果边界模糊</strong>，就会出现冲突，导致混乱。</li>
</ul>
<p>在软件开发中也是如此：</p>
<ul>
<li><strong>如果不同模块之间的边界清晰</strong>，每个模块都可以独立开发和测试。</li>
<li><strong>如果边界模糊</strong>，模块之间会产生复杂的依赖关系，导致代码难以维护。</li>
</ul>
<hr>
<h5 id="为什么边界重要？"><a href="#为什么边界重要？" class="headerlink" title="为什么边界重要？"></a><strong>为什么边界重要？</strong></h5><h3 id="（1）提高可维护性"><a href="#（1）提高可维护性" class="headerlink" title="（1）提高可维护性"></a><strong>（1）提高可维护性</strong></h3><ul>
<li>良好的边界划分可以让代码更加<strong>模块化</strong>，避免代码交叉污染。</li>
<li>例如：<ul>
<li>订单系统（Order Service）不应该知道库存系统（Inventory Service）是如何管理库存的，只需要调用其 API 即可。</li>
</ul>
</li>
</ul>
<h3 id="（2）提高可测试性-1"><a href="#（2）提高可测试性-1" class="headerlink" title="（2）提高可测试性"></a><strong>（2）提高可测试性</strong></h3><ul>
<li><p>如果不同模块之间有清晰的边界，我们可以使用<strong>Mock</strong> 来替代真实的依赖，进行单元测试。</p>
</li>
<li><p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCaseTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlaceOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderRepository mockRepo = mock(OrderRepository.class);</span><br><span class="line">        PaymentService mockPayment = mock(PaymentService.class);</span><br><span class="line">        when(mockPayment.charge(any())).thenReturn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        PlaceOrderUseCase useCase = <span class="keyword">new</span> PlaceOrderUseCase(mockRepo, mockPayment);</span><br><span class="line">        Order order = <span class="keyword">new</span> Order(<span class="string">&quot;123&quot;</span>, List.of(<span class="keyword">new</span> Item(<span class="string">&quot;item1&quot;</span>, <span class="number">100</span>)));</span><br><span class="line"></span><br><span class="line">        useCase.execute(order);</span><br><span class="line">        verify(mockRepo).save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 <code>PlaceOrderUseCase</code> 依赖抽象 <code>OrderRepository</code>，我们可以用 <code>Mock</code> 代替数据库，避免依赖真实环境进行测试。</li>
</ul>
</li>
</ul>
<h3 id="（3）提高灵活性"><a href="#（3）提高灵活性" class="headerlink" title="（3）提高灵活性"></a><strong>（3）提高灵活性</strong></h3><ul>
<li>如果系统有良好的边界划分，我们可以<strong>轻松替换某个模块</strong>，而不会影响其他模块。</li>
<li>例如：<ul>
<li>如果我们想要从 MySQL 迁移到 MongoDB，只需要更换 <code>OrderRepository</code> 的实现，而不需要修改业务逻辑。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="如何划分边界？"><a href="#如何划分边界？" class="headerlink" title="如何划分边界？"></a><strong>如何划分边界？</strong></h5><h3 id="（1）基于业务功能划分"><a href="#（1）基于业务功能划分" class="headerlink" title="（1）基于业务功能划分"></a><strong>（1）基于业务功能划分</strong></h3><ul>
<li><p><strong>错误的划分</strong>：</p>
<ul>
<li>订单（Order）模块和支付（Payment）模块直接共享数据库：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">JOIN</span> payments <span class="keyword">ON</span> orders.order_id <span class="operator">=</span> payments.order_id;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>问题</p>
<p>：</p>
<ul>
<li>订单模块和支付模块之间的边界模糊，任何对数据库结构的修改都会影响两个模块。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>正确的划分</strong>：</p>
<ul>
<li>订单模块和支付模块通过 API 交互，而不是共享数据库：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(PaymentService paymentService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = paymentService.charge(order);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="comment">// 订单处理逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在，订单模块和支付模块之间的边界清晰：<ul>
<li>订单模块不关心支付模块的具体实现。</li>
<li>未来如果要更换支付系统（例如从 PayPal 切换到 Stripe），只需要更改 <code>PaymentService</code> 的实现，而不会影响 <code>OrderService</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="（2）基于技术层划分"><a href="#（2）基于技术层划分" class="headerlink" title="（2）基于技术层划分"></a><strong>（2）基于技术层划分</strong></h3><p>在整洁架构（Clean Architecture）中，我们可以使用 <strong>同心圆模型</strong> 来定义边界：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Entities] ← [Use Cases] ← [Interface Adapters] ← [Frameworks &amp; Drivers]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实体层（Entities）</strong>：核心业务逻辑，不能依赖任何外部技术。</li>
<li><strong>用例层（Use Cases）</strong>：应用逻辑，调用实体，并与外部世界交互，但不直接依赖外部框架。</li>
<li><strong>接口适配层（Interface Adapters）</strong>：处理数据库、API、UI 等输入输出，转换数据格式。</li>
<li><strong>框架 &amp; 驱动层（Frameworks &amp; Drivers）</strong>：外部技术，如 Web 框架、数据库、消息队列等。</li>
</ul>
<p><strong>示例：订单管理系统</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用例层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> paymentSuccess = paymentService.charge(order);</span><br><span class="line">        <span class="keyword">if</span> (paymentSuccess) &#123;</span><br><span class="line">            orderRepository.save(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123; <span class="comment">/* 存入 MySQL */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架层（Spring Controller）</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Order placed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>订单业务逻辑只在 <code>Use Case</code> 层中处理，不依赖数据库或 Web 框架</strong>。</li>
<li><strong>数据库、API、UI 都是外部实现，未来可以自由更换而不影响核心业务逻辑</strong>。</li>
</ul>
<hr>
<h2 id="5-个人理解"><a href="#5-个人理解" class="headerlink" title="5. 个人理解"></a><strong>5. 个人理解</strong></h2><h3 id="1-“边界”-≠-“物理拆分”"><a href="#1-“边界”-≠-“物理拆分”" class="headerlink" title="1. “边界” ≠ “物理拆分”"></a><strong>1. “边界” ≠ “物理拆分”</strong></h3><ul>
<li>很多人认为“边界”就意味着“微服务”，但实际上，<strong>单体架构（Monolithic）也可以有良好的边界划分</strong>。</li>
<li><strong>关键不是是否拆分成多个服务，而是模块之间是否有清晰的边界。</strong></li>
</ul>
<h3 id="2-“错误的边界比没有边界更糟糕”"><a href="#2-“错误的边界比没有边界更糟糕”" class="headerlink" title="2. “错误的边界比没有边界更糟糕”"></a><strong>2. “错误的边界比没有边界更糟糕”</strong></h3><ul>
<li>如果边界划分不合理，可能会导致模块之间大量交互，增加复杂性。</li>
<li><strong>建议：先在代码层面划分边界，确定模块独立性，再决定是否拆分成微服务。</strong></li>
</ul>
<hr>
<h3 id="边界的解剖"><a href="#边界的解剖" class="headerlink" title="边界的解剖"></a>边界的解剖</h3><h1 id="第-18-章：Boundaries-Anatomy（边界的解剖）"><a href="#第-18-章：Boundaries-Anatomy（边界的解剖）" class="headerlink" title="第 18 章：Boundaries: Anatomy（边界的解剖）"></a>第 18 章：Boundaries: Anatomy（边界的解剖）</h1><p>在 <em>Clean Architecture</em> 的第 18 章，Uncle Bob 进一步深入探讨了 <strong>“边界”</strong>（Boundaries）的具体结构，以及如何在软件架构中正确定义边界，使得系统更易于扩展、测试和维护。</p>
<p>这一章的核心观点包括：</p>
<ol>
<li><strong>边界不仅仅是代码的组织方式，它决定了系统如何解耦和交互。</strong></li>
<li><strong>良好的边界设计可以降低模块之间的依赖，使得不同模块可以独立开发和测试。</strong></li>
<li><strong>在实践中，边界通常以接口、抽象类和适配器模式的形式体现。</strong></li>
</ol>
<hr>
<h2 id="1-为什么边界重要？"><a href="#1-为什么边界重要？" class="headerlink" title="1. 为什么边界重要？"></a><strong>1. 为什么边界重要？</strong></h2><p>在软件开发中，<strong>边界的作用是隔离不同的关注点</strong>，确保系统的各个部分可以<strong>独立变化</strong>，而不会影响其他部分。</p>
<h3 id="现实世界的类比-1"><a href="#现实世界的类比-1" class="headerlink" title="现实世界的类比"></a><strong>现实世界的类比</strong></h3><p>想象软件系统像一个公司：</p>
<ul>
<li><strong>如果没有明确的职责边界</strong>，每个员工都会直接与所有部门沟通，导致管理混乱，信息难以追踪。</li>
<li><strong>如果有明确的边界（如经理、中层管理）</strong>，不同团队之间的协作会更顺畅，每个团队可以专注于自己的工作。</li>
</ul>
<p>在软件架构中：</p>
<ul>
<li><strong>如果模块之间没有清晰的边界</strong>，任何代码修改都可能影响整个系统。</li>
<li><strong>如果模块之间通过接口交互</strong>，系统的不同部分可以独立开发、替换和测试。</li>
</ul>
<hr>
<h2 id="2-软件中的边界"><a href="#2-软件中的边界" class="headerlink" title="2. 软件中的边界"></a><strong>2. 软件中的边界</strong></h2><h3 id="（1）架构层级的边界"><a href="#（1）架构层级的边界" class="headerlink" title="（1）架构层级的边界"></a><strong>（1）架构层级的边界</strong></h3><p>在整洁架构（Clean Architecture）中，系统通常由多个层级组成，每一层都有自己的边界：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Entities] ← [Use Cases] ← [Interface Adapters] ← [Frameworks &amp; Drivers]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实体层（Entities）</strong>：核心业务逻辑，不依赖任何外部技术。</li>
<li><strong>用例层（Use Cases）</strong>：定义业务流程，与 UI、数据库解耦。</li>
<li><strong>接口适配层（Interface Adapters）</strong>：连接业务逻辑和外部世界（如 Web、数据库）。</li>
<li><strong>框架 &amp; 驱动层（Frameworks &amp; Drivers）</strong>：外部技术细节，如数据库、Web 框架等。</li>
</ul>
<p><strong>示例：订单管理系统</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用例层（业务逻辑）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlaceOrderUseCase</span><span class="params">(OrderRepository orderRepository, PaymentService paymentService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">        <span class="keyword">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> paymentSuccess = paymentService.charge(order);</span><br><span class="line">        <span class="keyword">if</span> (paymentSuccess) &#123;</span><br><span class="line">            orderRepository.save(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配层（数据库）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123; <span class="comment">/* 存入 MySQL */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配层（Web API）</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Order placed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>边界 1</strong>：<code>PlaceOrderUseCase</code> 依赖 <code>OrderRepository</code> 接口，而不是具体实现。</li>
<li><strong>边界 2</strong>：<code>OrderController</code> 依赖 <code>PlaceOrderUseCase</code>，但不关心数据库或支付实现。</li>
</ul>
<hr>
<h3 id="（2）进程边界"><a href="#（2）进程边界" class="headerlink" title="（2）进程边界"></a><strong>（2）进程边界</strong></h3><p>在分布式系统中，服务之间的交互通常通过 API，而不是直接调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">charge</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>PaymentService</code> 是一个独立的微服务，我们可以使用 HTTP 调用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpPaymentService</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">charge</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        HttpResponse response = httpClient.post(<span class="string">&quot;http://payment-service/charge&quot;</span>, order);</span><br><span class="line">        <span class="keyword">return</span> response.getStatus() == <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样，即使 <code>PaymentService</code> 迁移到不同的技术栈，<code>PlaceOrderUseCase</code> 依然可以正常工作。</li>
</ul>
<hr>
<h3 id="（3）线程边界"><a href="#（3）线程边界" class="headerlink" title="（3）线程边界"></a><strong>（3）线程边界</strong></h3><ul>
<li>在并发系统中，不同线程之间应该有清晰的边界，以避免竞态条件（Race Condition）。</li>
<li>例如，在 Java 多线程应用中，我们可以使用 <strong>消息队列（Message Queue）</strong> 作为边界：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        queue.send(<span class="string">&quot;orderQueue&quot;</span>, order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样，订单处理逻辑可以异步执行，而不会影响主线程的响应时间。</li>
</ul>
<hr>
<h2 id="3-代码中的边界模式"><a href="#3-代码中的边界模式" class="headerlink" title="3. 代码中的边界模式"></a><strong>3. 代码中的边界模式</strong></h2><h3 id="（1）依赖倒置（Dependency-Inversion）"><a href="#（1）依赖倒置（Dependency-Inversion）" class="headerlink" title="（1）依赖倒置（Dependency Inversion）"></a><strong>（1）依赖倒置（Dependency Inversion）</strong></h3><ul>
<li><strong>错误的做法</strong>：业务逻辑直接依赖数据库实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MySQLOrderRepository orderRepository; <span class="comment">// 直接依赖 MySQL</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = <span class="keyword">new</span> MySQLOrderRepository();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>正确的做法</strong>：使用接口作为边界：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(OrderRepository orderRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这样，我们可以轻松切换数据库实现，而不影响 <code>OrderService</code>。</li>
</ul>
<hr>
<h3 id="（2）适配器模式（Adapter-Pattern）"><a href="#（2）适配器模式（Adapter-Pattern）" class="headerlink" title="（2）适配器模式（Adapter Pattern）"></a><strong>（2）适配器模式（Adapter Pattern）</strong></h3><ul>
<li>适配器（Adapter）可以充当<strong>边界的桥梁</strong>，将不同的接口连接在一起：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentAdapter</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExternalPaymentGateway externalGateway;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PaymentAdapter</span><span class="params">(ExternalPaymentGateway externalGateway)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.externalGateway = externalGateway;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">charge</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> externalGateway.processPayment(order.getAmount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>PaymentAdapter</code> 充当边界，使 <code>OrderService</code> 不依赖 <code>ExternalPaymentGateway</code> 的具体实现</strong>。</li>
</ul>
<h3 id="策略与层次"><a href="#策略与层次" class="headerlink" title="策略与层次"></a>策略与层次</h3><p>在 <em>Clean Architecture</em> 的第 19 章，Uncle Bob 讨论了<strong>“策略”</strong>（Policy）和<strong>“层次”</strong>（Level）在软件架构中的作用，并强调如何根据不同层次划分业务逻辑，使系统保持清晰的结构和高可维护性。</p>
<p>这一章的核心观点包括：</p>
<ol>
<li><strong>软件架构不仅仅是代码的组织方式，更是一种策略（Policy），用于管理不同层次的依赖关系。</strong></li>
<li><strong>好的架构应该保证核心业务逻辑不受外部技术的限制，确保代码的独立性和可扩展性。</strong></li>
<li><strong>通过合理的层次划分，系统可以在不影响核心逻辑的情况下更换 UI、数据库、甚至外部 API。</strong></li>
</ol>
<hr>
<h2 id="1-什么是“策略”"><a href="#1-什么是“策略”" class="headerlink" title="1. 什么是“策略”"></a><strong>1. 什么是“策略”</strong></h2><p>在软件架构中，<strong>策略（Policy）指的是业务规则和逻辑，而不是具体的技术实现。</strong></p>
<p>Uncle Bob 指出，软件系统通常包含 <strong>两种不同层次的策略</strong>：</p>
<ol>
<li><p>高层策略（High-Level Policy）</p>
<p>：</p>
<ul>
<li>这些是系统的核心业务逻辑，与具体的技术（数据库、UI、框架）无关。</li>
<li>例如：订单折扣规则、用户权限管理、支付计算逻辑。</li>
</ul>
</li>
<li><p>低层策略（Low-Level Policy）</p>
<p>：</p>
<ul>
<li>这些是系统的实现细节，如数据库访问、Web 框架、外部 API。</li>
<li>例如：SQL 查询、REST API 调用、React 组件。</li>
</ul>
</li>
</ol>
<h3 id="示例：电商订单系统"><a href="#示例：电商订单系统" class="headerlink" title="示例：电商订单系统"></a><strong>示例：电商订单系统</strong></h3><ul>
<li><p><strong>高层策略（核心业务逻辑）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalPrice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateTotalPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        totalPrice = items.stream()</span><br><span class="line">                .mapToDouble(OrderItem::getPrice)</span><br><span class="line">                .sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的 <code>calculateTotalPrice()</code> 逻辑<strong>不依赖数据库或 UI</strong>，它是一个<strong>纯业务规则</strong>。</li>
</ul>
</li>
<li><p><strong>低层策略（数据库访问层）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;INSERT INTO orders VALUES (?, ?)&quot;</span>, order.getId(), order.getTotalPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个 <code>MySQLOrderRepository</code> 处理数据库存储，但**它不应该影响核心业务逻辑 <code>Order</code>**。</li>
</ul>
</li>
</ul>
<p><strong>👉 关键思想：</strong></p>
<blockquote>
<p><strong>业务逻辑（高层策略）应该独立于外部实现（低层策略），以保持系统的灵活性和可扩展性。</strong></p>
</blockquote>
<hr>
<h2 id="2-什么是“层次”？"><a href="#2-什么是“层次”？" class="headerlink" title="2. 什么是“层次”？"></a><strong>2. 什么是“层次”？</strong></h2><p><strong>层次（Level）是指软件系统中的不同抽象级别，它决定了系统的依赖方向。</strong></p>
<p>在整洁架构（Clean Architecture）中，我们可以把系统分成 <strong>四个主要层次</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Entities] ← [Use Cases] ← [Interface Adapters] ← [Frameworks &amp; Drivers]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实体层（Entities）</strong>：核心业务规则，不依赖外部技术。</li>
<li><strong>用例层（Use Cases）</strong>：应用逻辑，与 UI、数据库解耦。</li>
<li><strong>接口适配层（Interface Adapters）</strong>：适配 UI、数据库、API。</li>
<li><strong>框架 &amp; 驱动层（Frameworks &amp; Drivers）</strong>：外部技术，如数据库、Web 框架等。</li>
</ul>
<h3 id="示例：订单管理系统"><a href="#示例：订单管理系统" class="headerlink" title="示例：订单管理系统"></a><strong>示例：订单管理系统</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// **实体层（核心业务逻辑）**</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalPrice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateTotalPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        totalPrice = items.stream().mapToDouble(OrderItem::getPrice).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **用例层（应用逻辑）**</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlaceOrderUseCase</span><span class="params">(OrderRepository orderRepository, PaymentService paymentService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">        <span class="keyword">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        order.calculateTotalPrice();</span><br><span class="line">        <span class="keyword">boolean</span> paymentSuccess = paymentService.charge(order);</span><br><span class="line">        <span class="keyword">if</span> (paymentSuccess) &#123;</span><br><span class="line">            orderRepository.save(order);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **接口适配层（数据库、API 适配器）**</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123; <span class="comment">/* 存入 MySQL */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **框架层（Spring Controller）**</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Order placed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>业务逻辑 <code>Order</code> 和 <code>PlaceOrderUseCase</code> 并不依赖数据库或 Web 框架</strong>。</li>
<li><strong>不同层之间通过“接口”进行交互，而不是直接调用具体实现</strong>，这让系统更具灵活性。</li>
</ul>
<p><strong>👉 关键思想：</strong></p>
<blockquote>
<p><strong>层次决定了依赖方向：低层（如数据库）应该依赖高层（如业务逻辑），而不是反过来。</strong></p>
</blockquote>
<hr>
<h2 id="3-依赖方向与依赖倒置"><a href="#3-依赖方向与依赖倒置" class="headerlink" title="3. 依赖方向与依赖倒置"></a><strong>3. 依赖方向与依赖倒置</strong></h2><h3 id="错误的架构"><a href="#错误的架构" class="headerlink" title="错误的架构"></a><strong>错误的架构</strong></h3><p>如果系统的依赖方向是 <strong>从业务逻辑 → 框架</strong>，那么整个系统将变得难以维护：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Frameworks &amp; Drivers] → [Interface Adapters] → [Use Cases] → [Entities]</span><br></pre></td></tr></table></figure>

<ul>
<li>例如，如果 <code>Order</code> 直接依赖 <code>MySQL</code>，那么未来想更换数据库（如 MongoDB）就会非常困难。</li>
<li>业务逻辑和技术细节耦合在一起，任何小的技术变更都会影响整个系统。</li>
</ul>
<h3 id="正确的架构"><a href="#正确的架构" class="headerlink" title="正确的架构"></a><strong>正确的架构</strong></h3><p><strong>依赖应该指向“高层策略”，而不是“低层策略”</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Entities] ← [Use Cases] ← [Interface Adapters] ← [Frameworks &amp; Drivers]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>业务逻辑不会受到技术变更的影响</strong>，可以独立演进。</li>
<li><strong>不同的实现（如数据库、UI、API）可以随时替换，而不会影响核心逻辑。</strong></li>
</ul>
<hr>
<h2 id="4-现实世界的案例"><a href="#4-现实世界的案例" class="headerlink" title="4. 现实世界的案例"></a><strong>4. 现实世界的案例</strong></h2><h3 id="案例-1：Amazon"><a href="#案例-1：Amazon" class="headerlink" title="案例 1：Amazon"></a><strong>案例 1：Amazon</strong></h3><ul>
<li>Amazon 早期的系统是<strong>单体架构（Monolithic）</strong>，所有业务逻辑都依赖具体的数据库和 UI。</li>
<li>后来，他们拆分出 <strong>核心业务逻辑（订单、库存、支付）</strong>，让这些模块独立于具体的技术栈，形成了良好的架构层次。</li>
</ul>
<h3 id="案例-2：Netflix"><a href="#案例-2：Netflix" class="headerlink" title="案例 2：Netflix"></a><strong>案例 2：Netflix</strong></h3><ul>
<li>Netflix 采用 <strong>微服务架构</strong>，但他们的核心业务逻辑（用户推荐算法、视频存储等）是<strong>独立于数据库、API 和前端的</strong>。</li>
<li>这样，他们可以在不影响业务逻辑的情况下，更换数据库或前端技术栈。</li>
</ul>
<hr>
<h2 id="5-个人理解-1"><a href="#5-个人理解-1" class="headerlink" title="5. 个人理解"></a><strong>5. 个人理解</strong></h2><h3 id="1-“策略”-是架构的核心"><a href="#1-“策略”-是架构的核心" class="headerlink" title="1. “策略” 是架构的核心"></a><strong>1. “策略” 是架构的核心</strong></h3><ul>
<li><strong>好的架构应该把业务逻辑（高层策略）与技术细节（低层策略）解耦。</strong></li>
<li><strong>技术可以更换，但核心业务逻辑应该保持稳定。</strong></li>
</ul>
<h3 id="2-“层次”-决定了代码的可维护性"><a href="#2-“层次”-决定了代码的可维护性" class="headerlink" title="2. “层次” 决定了代码的可维护性"></a><strong>2. “层次” 决定了代码的可维护性</strong></h3><ul>
<li><strong>如果层次混乱，任何变更都会影响整个系统。</strong></li>
<li><strong>如果层次清晰，我们可以独立升级 UI、数据库，而不影响业务逻辑。</strong></li>
</ul>
<hr>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h2><ul>
<li><strong>“策略” 决定了系统的核心规则，而 “层次” 确保不同部分的独立性。</strong></li>
<li><strong>业务逻辑（高层策略）应该独立于技术细节（低层策略），以保证系统的灵活性。</strong></li>
<li><strong>合理的层次划分可以让系统更容易扩展、测试和重构。</strong></li>
</ul>
<p><strong>架构的目标不是选择技术，而是确保技术可以随时更换，而不影响核心业务逻辑！</strong></p>
<h3 id="业务规则"><a href="#业务规则" class="headerlink" title="业务规则"></a>业务规则</h3><h1 id="第-20-章：Business-Rules（业务规则）"><a href="#第-20-章：Business-Rules（业务规则）" class="headerlink" title="第 20 章：Business Rules（业务规则）"></a><strong>第 20 章：Business Rules（业务规则）</strong></h1><p>在 <em>Clean Architecture</em> 的第 20 章，Uncle Bob 讨论了<strong>业务规则（Business Rules）</strong>的概念，并强调了它们在软件架构中的核心地位。</p>
<p>本章的核心观点包括：</p>
<ol>
<li><strong>业务规则是整个软件系统的核心，所有其他部分（数据库、UI、框架）都是围绕业务规则展开的。</strong></li>
<li><strong>业务规则应该独立于具体的技术实现（如数据库、Web 框架、UI），以便保持灵活性和可维护性。</strong></li>
<li><strong>区分“企业级业务规则”（Enterprise Business Rules）和“应用级业务规则”（Application Business Rules），分别处理跨系统和应用内部的逻辑。</strong></li>
</ol>
<hr>
<h2 id="1-什么是业务规则？"><a href="#1-什么是业务规则？" class="headerlink" title="1. 什么是业务规则？"></a><strong>1. 什么是业务规则？</strong></h2><h3 id="业务规则的定义"><a href="#业务规则的定义" class="headerlink" title="业务规则的定义"></a><strong>业务规则的定义</strong></h3><p><strong>业务规则是系统必须遵守的一组约束和逻辑，它决定了系统如何处理数据和执行任务。</strong></p>
<p>例如，在一个电商系统中：</p>
<ul>
<li><strong>订单规则</strong>：订单必须至少包含一个商品。</li>
<li><strong>库存规则</strong>：如果库存不足，则不能下单。</li>
<li><strong>支付规则</strong>：订单金额大于 $100 时可享受 10% 的折扣。</li>
</ul>
<h3 id="业务规则-vs-业务流程"><a href="#业务规则-vs-业务流程" class="headerlink" title="业务规则 vs. 业务流程"></a><strong>业务规则 vs. 业务流程</strong></h3><ul>
<li><strong>业务规则</strong> 是不变的，例如：“订单总价 = 商品价格 × 数量” 这个规则在任何情况下都不会变。</li>
<li><strong>业务流程</strong> 可能会随组织需求变更，例如：“用户下单 → 生成订单 → 处理支付” 这个流程可能因支付方式或促销活动的不同而改变。</li>
</ul>
<p><strong>👉 关键思想：</strong></p>
<blockquote>
<p><strong>业务规则是稳定的，而业务流程是可变的。良好的架构应该确保业务规则不会因外部技术的变更而受影响。</strong></p>
</blockquote>
<hr>
<h2 id="2-业务规则的分类"><a href="#2-业务规则的分类" class="headerlink" title="2. 业务规则的分类"></a><strong>2. 业务规则的分类</strong></h2><p>Uncle Bob 将业务规则分为 <strong>两类</strong>：</p>
<ol>
<li><strong>企业级业务规则（Enterprise Business Rules）</strong><ul>
<li>这些规则适用于整个企业或多个系统之间。</li>
<li>例如，银行的“利率计算规则”、电商的“会员积分规则”等。</li>
<li><strong>通常封装在“实体层”（Entities）中，不依赖于应用的具体实现。</strong></li>
</ul>
</li>
<li><strong>应用级业务规则（Application Business Rules）</strong><ul>
<li>这些规则适用于特定的应用程序或服务。</li>
<li>例如，“用户必须登录才能下单” 这样的规则。</li>
<li><strong>通常封装在“用例层”（Use Cases）中，与具体的业务场景相关。</strong></li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-如何在代码中实现业务规则？"><a href="#3-如何在代码中实现业务规则？" class="headerlink" title="3. 如何在代码中实现业务规则？"></a><strong>3. 如何在代码中实现业务规则？</strong></h2><h3 id="（1）实体层：封装企业级业务规则"><a href="#（1）实体层：封装企业级业务规则" class="headerlink" title="（1）实体层：封装企业级业务规则"></a><strong>（1）实体层：封装企业级业务规则</strong></h3><p><strong>示例：订单的业务规则</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalPrice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(List&lt;OrderItem&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (items.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;订单必须至少包含一个商品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">        calculateTotalPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateTotalPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalPrice = items.stream().mapToDouble(OrderItem::getPrice).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Order</code> 代表了<strong>企业级业务规则</strong>，它不依赖于数据库、UI 或 Web 框架。</li>
<li><strong>即使我们更换数据库或 UI，<code>Order</code> 的逻辑仍然适用。</strong></li>
</ul>
<hr>
<h3 id="（2）用例层：封装应用级业务规则"><a href="#（2）用例层：封装应用级业务规则" class="headerlink" title="（2）用例层：封装应用级业务规则"></a><strong>（2）用例层：封装应用级业务规则</strong></h3><p><strong>示例：下订单的用例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlaceOrderUseCase</span><span class="params">(OrderRepository orderRepository, PaymentService paymentService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">        <span class="keyword">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> paymentSuccess = paymentService.charge(order);</span><br><span class="line">        <span class="keyword">if</span> (paymentSuccess) &#123;</span><br><span class="line">            orderRepository.save(order);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;支付失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PlaceOrderUseCase</code> 负责<strong>应用级业务规则</strong>，如“必须先支付成功才能存储订单”。</li>
<li><strong>它依赖于 <code>OrderRepository</code> 和 <code>PaymentService</code>，但并不关心它们的具体实现（MySQL、MongoDB、Stripe、PayPal 等）。</strong></li>
</ul>
<hr>
<h3 id="（3）数据库和-Web-层：不包含业务规则"><a href="#（3）数据库和-Web-层：不包含业务规则" class="headerlink" title="（3）数据库和 Web 层：不包含业务规则"></a><strong>（3）数据库和 Web 层：不包含业务规则</strong></h3><p>在 <strong>整洁架构</strong> 中：</p>
<ul>
<li><strong>数据库层（Repositories）</strong> 只负责数据存储，不包含业务逻辑：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySQLOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123; <span class="comment">/* 存入 MySQL */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Web 层（Controllers）</strong> 只负责请求处理，不包含业务逻辑：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderController</span><span class="params">(PlaceOrderUseCase placeOrderUseCase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.placeOrderUseCase = placeOrderUseCase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/order&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> Order order)</span> </span>&#123;</span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Order placed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>👉 关键思想：</strong></p>
<blockquote>
<p><strong>所有的业务逻辑都应该封装在“实体层”和“用例层”，而数据库、UI、API 只负责数据存储和交互，不应该承担业务逻辑。</strong></p>
</blockquote>
<hr>
<h2 id="4-为什么要让业务规则独立于技术？"><a href="#4-为什么要让业务规则独立于技术？" class="headerlink" title="4. 为什么要让业务规则独立于技术？"></a><strong>4. 为什么要让业务规则独立于技术？</strong></h2><h3 id="（1）提高可维护性-1"><a href="#（1）提高可维护性-1" class="headerlink" title="（1）提高可维护性"></a><strong>（1）提高可维护性</strong></h3><ul>
<li><p><strong>如果业务规则与数据库、UI 绑定在一起，每次更换技术都要修改大量代码。</strong></p>
</li>
<li><p>例如，如果 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Order</span><br></pre></td></tr></table></figure>

<p> 依赖于 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL</span><br></pre></td></tr></table></figure>

<p>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MySQLOrderRepository repository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123; repository.save(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题</strong>：如果未来要换成 <code>MongoDB</code>，<code>Order</code> 也必须修改。</li>
<li><strong>正确的做法</strong>：让 <code>Order</code> 只处理业务逻辑，数据存储交给 <code>OrderRepository</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="（2）提高可测试性-2"><a href="#（2）提高可测试性-2" class="headerlink" title="（2）提高可测试性"></a><strong>（2）提高可测试性</strong></h3><ul>
<li><strong>如果业务逻辑独立，我们可以在不依赖数据库、Web 服务器的情况下测试核心逻辑。</strong></li>
<li><strong>示例：测试订单计算逻辑</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCalculateTotalPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;OrderItem&gt; items = List.of(<span class="keyword">new</span> OrderItem(<span class="string">&quot;item1&quot;</span>, <span class="number">50</span>), <span class="keyword">new</span> OrderItem(<span class="string">&quot;item2&quot;</span>, <span class="number">100</span>));</span><br><span class="line">        Order order = <span class="keyword">new</span> Order(items);</span><br><span class="line">        assertEquals(<span class="number">150</span>, order.getTotalPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例：测试下单用例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCaseTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlaceOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderRepository mockRepo = mock(OrderRepository.class);</span><br><span class="line">        PaymentService mockPayment = mock(PaymentService.class);</span><br><span class="line">        when(mockPayment.charge(any())).thenReturn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        PlaceOrderUseCase useCase = <span class="keyword">new</span> PlaceOrderUseCase(mockRepo, mockPayment);</span><br><span class="line">        Order order = <span class="keyword">new</span> Order(List.of(<span class="keyword">new</span> OrderItem(<span class="string">&quot;item1&quot;</span>, <span class="number">100</span>)));</span><br><span class="line"></span><br><span class="line">        useCase.execute(order);</span><br><span class="line">        verify(mockRepo).save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 <code>PlaceOrderUseCase</code> <strong>不依赖数据库、UI，我们可以用 Mock 测试，而不需要真实环境</strong>。</li>
</ul>
<hr>
<h2 id="5-现实世界的案例"><a href="#5-现实世界的案例" class="headerlink" title="5. 现实世界的案例"></a><strong>5. 现实世界的案例</strong></h2><h3 id="案例-1：Amazon-1"><a href="#案例-1：Amazon-1" class="headerlink" title="案例 1：Amazon"></a><strong>案例 1：Amazon</strong></h3><ul>
<li>Amazon 拆分了 <strong>订单、支付、库存等核心业务逻辑</strong>，让它们独立于 UI、数据库和 API。</li>
<li>这样，即使 Amazon 从 Web 扩展到 Mobile，核心业务规则仍然适用。</li>
</ul>
<h3 id="案例-2：银行系统"><a href="#案例-2：银行系统" class="headerlink" title="案例 2：银行系统"></a><strong>案例 2：银行系统</strong></h3><ul>
<li>银行的 <strong>利率计算、信用评分、风控规则</strong> 都是 <strong>业务规则</strong>，不会因为前端技术（Web、App）而改变。</li>
<li>这些业务规则通常被封装在 <strong>独立的领域模型（Domain Model）</strong> 中。</li>
</ul>
<hr>
<h2 id="6-结论-1"><a href="#6-结论-1" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h2><ul>
<li><strong>业务规则是系统的核心，所有技术（UI、数据库、API）都应该围绕业务规则展开。</strong></li>
<li><strong>业务规则应该独立于数据库、UI 和框架，以保持灵活性和可维护性。</strong></li>
<li><strong>良好的架构应该确保在更换数据库、UI、API 时，业务逻辑可以保持不变。</strong></li>
</ul>
<p>🚀 <strong>架构的目标是让业务逻辑长久稳定，而不是被技术实现所限制！</strong></p>
<h3 id="架构应该大声“呼喊”它的目标"><a href="#架构应该大声“呼喊”它的目标" class="headerlink" title="架构应该大声“呼喊”它的目标"></a>架构应该大声“呼喊”它的目标</h3><h1 id="第-21-章：Screaming-Architecture（架构应该大声“呼喊”它的目标）"><a href="#第-21-章：Screaming-Architecture（架构应该大声“呼喊”它的目标）" class="headerlink" title="第 21 章：Screaming Architecture（架构应该大声“呼喊”它的目标）"></a><strong>第 21 章：Screaming Architecture（架构应该大声“呼喊”它的目标）</strong></h1><p>在 <em>Clean Architecture</em> 的第 21 章，Uncle Bob 提出了一个有趣的问题：<strong>“你的架构在大声呼喊什么？”</strong></p>
<p>本章的核心观点包括：</p>
<ol>
<li><strong>一个好的软件架构应该清晰地表达其核心业务，而不是技术实现细节。</strong></li>
<li><strong>系统的组织方式应该反映业务，而不是框架、数据库或其他技术。</strong></li>
<li><strong>代码结构应该能让开发者一眼看出系统的主要用途，而不是被技术细节所主导。</strong></li>
</ol>
<hr>
<h2 id="1-什么是“架构在呼喊什么”？"><a href="#1-什么是“架构在呼喊什么”？" class="headerlink" title="1. 什么是“架构在呼喊什么”？"></a><strong>1. 什么是“架构在呼喊什么”？</strong></h2><p>Uncle Bob 认为，<strong>架构的第一印象应该清楚地展现系统的核心业务，而不是技术栈</strong>。</p>
<ul>
<li><strong>不好的架构：</strong> 让人一看就知道是用了什么技术，而不知道它解决什么问题。</li>
<li><strong>好的架构：</strong> 让人一看就知道系统的业务是什么，而不关心它使用了什么技术。</li>
</ul>
<h3 id="示例：一个典型的-Web-项目"><a href="#示例：一个典型的-Web-项目" class="headerlink" title="示例：一个典型的 Web 项目"></a><strong>示例：一个典型的 Web 项目</strong></h3><h4 id="（错误示例）技术导向的架构"><a href="#（错误示例）技术导向的架构" class="headerlink" title="（错误示例）技术导向的架构"></a><strong>（错误示例）技术导向的架构</strong></h4><p>许多 Web 项目在组织代码时，会优先按照技术来划分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/controllers</span><br><span class="line">/services</span><br><span class="line">/repositories</span><br><span class="line">/models</span><br><span class="line">/config</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li>看到 <code>controllers/</code>、<code>services/</code> 这样的目录，开发者只能知道系统用了 <strong>MVC</strong>，但看不出这个系统是做什么的。</li>
<li>这个架构<strong>优先强调技术（Spring, Django, Express）</strong>，而不是业务逻辑。</li>
<li>如果你把这个项目交给一个新开发者，他需要阅读大量代码，才能弄清楚这个系统的业务目标。</li>
</ul>
<h4 id="（正确示例）业务导向的架构"><a href="#（正确示例）业务导向的架构" class="headerlink" title="（正确示例）业务导向的架构"></a><strong>（正确示例）业务导向的架构</strong></h4><p>如果我们按照业务领域来组织代码，而不是技术层面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">   ├── Order.java</span><br><span class="line">   ├── PlaceOrderUseCase.java</span><br><span class="line">   ├── OrderRepository.java</span><br><span class="line">   ├── OrderController.java</span><br><span class="line">/payments</span><br><span class="line">   ├── Payment.java</span><br><span class="line">   ├── ProcessPaymentUseCase.java</span><br><span class="line">   ├── PaymentGateway.java</span><br><span class="line">   ├── PaymentController.java</span><br></pre></td></tr></table></figure>

<p><strong>优势：</strong></p>
<ul>
<li>一眼就能看出，这个系统涉及 <strong>订单（Orders）和支付（Payments）</strong>，而不是一个“Spring + MySQL”项目。</li>
<li><strong>业务逻辑是核心，而技术只是细节。</strong></li>
<li>开发者不需要了解框架，就能快速理解系统的功能。</li>
</ul>
<hr>
<h2 id="2-为什么大多数架构在“呼喊技术”？"><a href="#2-为什么大多数架构在“呼喊技术”？" class="headerlink" title="2. 为什么大多数架构在“呼喊技术”？"></a><strong>2. 为什么大多数架构在“呼喊技术”？</strong></h2><h3 id="（1）流行框架的影响"><a href="#（1）流行框架的影响" class="headerlink" title="（1）流行框架的影响"></a><strong>（1）流行框架的影响</strong></h3><p>许多开发者在学习新技术（Spring、Django、Rails）时，会按照框架推荐的方式来组织代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/controllers</span><br><span class="line">/services</span><br><span class="line">/repositories</span><br></pre></td></tr></table></figure>

<p>但这其实是 <strong>框架驱动的架构（Framework-Driven Architecture）</strong>，而不是 <strong>业务驱动的架构（Business-Driven Architecture）</strong>。</p>
<p><strong>问题：</strong></p>
<ul>
<li>业务逻辑被分散到不同的 <code>controllers/</code>、<code>services/</code> 里，难以管理。</li>
<li>代码组织方式依赖框架，导致迁移成本高（比如从 Spring 迁移到 Django 会很痛苦）。</li>
<li>重点是“我们在用 Spring”，而不是“我们在处理订单、支付等业务”。</li>
</ul>
<hr>
<h3 id="（2）数据库驱动的架构"><a href="#（2）数据库驱动的架构" class="headerlink" title="（2）数据库驱动的架构"></a><strong>（2）数据库驱动的架构</strong></h3><p>很多企业系统采用 <strong>数据库驱动架构（Database-Driven Architecture）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/entities</span><br><span class="line">    ├── OrderEntity.java</span><br><span class="line">    ├── PaymentEntity.java</span><br><span class="line">/repositories</span><br><span class="line">    ├── OrderRepository.java</span><br><span class="line">    ├── PaymentRepository.java</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<ul>
<li><strong>业务逻辑被数据库设计所主导，系统的组织方式围绕数据表，而不是业务流程。</strong></li>
<li><strong>难以扩展</strong>：如果业务规则变更，代码组织方式也需要调整。</li>
<li><strong>难以测试</strong>：业务逻辑被嵌套在 <code>repositories/</code> 里，无法在没有数据库的情况下测试。</li>
</ul>
<hr>
<h2 id="3-如何让架构“呼喊”业务？"><a href="#3-如何让架构“呼喊”业务？" class="headerlink" title="3. 如何让架构“呼喊”业务？"></a><strong>3. 如何让架构“呼喊”业务？</strong></h2><h3 id="（1）按业务组织代码，而不是按技术"><a href="#（1）按业务组织代码，而不是按技术" class="headerlink" title="（1）按业务组织代码，而不是按技术"></a><strong>（1）按业务组织代码，而不是按技术</strong></h3><p><strong>正确的做法：</strong> 让代码结构直接反映业务领域：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/orders</span><br><span class="line">   ├── Order.java</span><br><span class="line">   ├── PlaceOrderUseCase.java</span><br><span class="line">   ├── OrderRepository.java</span><br><span class="line">   ├── OrderController.java</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>这样，新开发者一眼就能看出系统的核心业务，而不是框架结构。</strong></li>
<li><strong>数据库、框架等技术细节只是业务模块的一部分，而不是主导整个架构。</strong></li>
</ul>
<h3 id="（2）使用整洁架构"><a href="#（2）使用整洁架构" class="headerlink" title="（2）使用整洁架构"></a><strong>（2）使用整洁架构</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Entities] ← [Use Cases] ← [Interface Adapters] ← [Frameworks &amp; Drivers]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Entities（实体层）</strong>：包含企业级业务规则，如 <code>Order</code>、<code>Payment</code>。</li>
<li><strong>Use Cases（用例层）</strong>：封装应用级业务逻辑，如 <code>PlaceOrderUseCase</code>、<code>ProcessPaymentUseCase</code>。</li>
<li><strong>Interface Adapters（适配层）</strong>：适配数据库、UI、API，如 <code>OrderRepository</code>、<code>OrderController</code>。</li>
<li><strong>Frameworks &amp; Drivers（框架层）</strong>：Spring、Django、MySQL、PostgreSQL 等。</li>
</ul>
<h3 id="（3）推迟技术决策"><a href="#（3）推迟技术决策" class="headerlink" title="（3）推迟技术决策"></a><strong>（3）推迟技术决策</strong></h3><p><strong>避免在架构早期绑定某个框架或数据库</strong>，而是：</p>
<ul>
<li><strong>先定义业务规则和用例</strong></li>
<li><strong>再决定数据库、Web 框架、外部 API</strong></li>
</ul>
<p>如果系统的业务逻辑足够清晰，那么：</p>
<ul>
<li><strong>可以在不影响核心业务的情况下更换 UI（Web → Mobile）</strong></li>
<li><strong>可以轻松替换数据库（MySQL → MongoDB）</strong></li>
<li><strong>可以升级 Web 框架（Spring → Micronaut）</strong></li>
</ul>
<hr>
<h2 id="4-现实世界的案例-1"><a href="#4-现实世界的案例-1" class="headerlink" title="4. 现实世界的案例"></a><strong>4. 现实世界的案例</strong></h2><h3 id="案例-1：Amazon-2"><a href="#案例-1：Amazon-2" class="headerlink" title="案例 1：Amazon"></a><strong>案例 1：Amazon</strong></h3><ul>
<li>Amazon 的架构强调 <strong>订单、库存、物流、支付等业务</strong>，而不是某个具体的数据库或 Web 框架。</li>
<li><strong>即使技术栈发生变化，业务核心仍然稳定。</strong></li>
</ul>
<h3 id="案例-2：Netflix-1"><a href="#案例-2：Netflix-1" class="headerlink" title="案例 2：Netflix"></a><strong>案例 2：Netflix</strong></h3><ul>
<li>Netflix 的架构围绕 <strong>推荐系统、视频流、用户管理</strong> 这些核心业务，而不是“我们用了什么框架”。</li>
<li><strong>Netflix 可以自由更换数据库、微服务架构，而不会影响核心业务。</strong></li>
</ul>
<hr>
<h2 id="5-个人理解-2"><a href="#5-个人理解-2" class="headerlink" title="5. 个人理解"></a><strong>5. 个人理解</strong></h2><h3 id="1-“框架是细节，业务才是核心”"><a href="#1-“框架是细节，业务才是核心”" class="headerlink" title="1. “框架是细节，业务才是核心”"></a><strong>1. “框架是细节，业务才是核心”</strong></h3><ul>
<li><strong>很多开发者把“Spring 项目”或“Django 项目”当作架构，但这只是技术选择，而不是业务架构。</strong></li>
<li><strong>一个好的架构，应该能够脱离具体的框架，仍然能表达清晰的业务逻辑。</strong></li>
</ul>
<h3 id="2-“按业务组织代码，而不是按技术”"><a href="#2-“按业务组织代码，而不是按技术”" class="headerlink" title="2. “按业务组织代码，而不是按技术”"></a><strong>2. “按业务组织代码，而不是按技术”</strong></h3><ul>
<li><strong>不应该有 <code>/controllers</code>、<code>/services</code> 这样的技术导向结构，而应该有 <code>/orders</code>、<code>/payments</code> 这样的业务导向结构。</strong></li>
<li><strong>代码应该清晰地反映业务，而不是技术实现。</strong></li>
</ul>
<h3 id="3-“业务逻辑应该独立于技术栈”"><a href="#3-“业务逻辑应该独立于技术栈”" class="headerlink" title="3. “业务逻辑应该独立于技术栈”"></a><strong>3. “业务逻辑应该独立于技术栈”</strong></h3><ul>
<li><strong>如果你的业务逻辑不能在没有数据库的情况下运行，那么你的架构是不健康的。</strong></li>
<li><strong>如果你的系统无法在不修改业务逻辑的情况下更换 UI，那么你的架构是不灵活的。</strong></li>
</ul>
<hr>
<h5 id="6-结论-2"><a href="#6-结论-2" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h5><ul>
<li><strong>好的架构应该清楚地表达业务逻辑，而不是被技术细节所主导。</strong></li>
<li><strong>代码结构应该让开发者一眼就能看出系统的核心业务，而不是 Web 框架或数据库。</strong></li>
<li><strong>架构的目标是让系统适应变化，而不是被技术选型所限制。</strong></li>
</ul>
<p>🚀 <strong>“让你的架构大声呼喊它的目标，而不是框架！”</strong></p>
<h3 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h3><h3 id="Chapter-22-The-Clean-Architecture（整洁架构）"><a href="#Chapter-22-The-Clean-Architecture（整洁架构）" class="headerlink" title="Chapter 22: The Clean Architecture（整洁架构）"></a><strong>Chapter 22: The Clean Architecture（整洁架构）</strong></h3><p>这一章是 <em>Clean Architecture</em> 这本书的核心部分，Uncle Bob 在这里详细介绍了他提出的 <strong>整洁架构（Clean Architecture）</strong>。整洁架构是一种软件架构模式，旨在保持代码的可维护性、可扩展性和可测试性，同时尽可能降低对框架、数据库、UI 和外部工具的依赖。</p>
<hr>
<h2 id="1-什么是整洁架构？"><a href="#1-什么是整洁架构？" class="headerlink" title="1. 什么是整洁架构？"></a><strong>1. 什么是整洁架构？</strong></h2><p>Uncle Bob 提出的整洁架构是对多个架构模式（如<strong>六边形架构、洋葱架构、依赖倒置原则</strong>等）的综合归纳。它的核心思想是：</p>
<ul>
<li><strong>保持软件核心（业务规则）的独立性</strong></li>
<li><strong>隔离不同层次的关注点</strong></li>
<li><strong>控制依赖方向，使得高层（业务逻辑）不依赖于底层（数据库、框架等）</strong></li>
<li><strong>提高系统的可测试性，使得业务逻辑可以独立于外部依赖进行测试</strong></li>
</ul>
<p>整洁架构通常以 <strong>同心圆模型</strong> 的形式表示，其中每一层都对外层隐藏实现细节，并且 <strong>依赖方向只能从外向内</strong>。</p>
<hr>
<h2 id="2-整洁架构的同心圆模型"><a href="#2-整洁架构的同心圆模型" class="headerlink" title="2. 整洁架构的同心圆模型"></a><strong>2. 整洁架构的同心圆模型</strong></h2><p>整洁架构通常由 <strong>四个主要层级</strong> 组成，从内到外依次是：</p>
<h3 id="1-实体（Entities）"><a href="#1-实体（Entities）" class="headerlink" title="(1) 实体（Entities）"></a><strong>(1) 实体（Entities）</strong></h3><ul>
<li>实体是企业级的业务规则，它们独立于任何具体的应用程序。</li>
<li>这些实体可以在不同的应用程序中被复用，例如：订单（Order）、用户（User）、产品（Product）等。</li>
<li>实体中的规则通常不会随 UI、数据库或其他技术变更而改变。</li>
</ul>
<h3 id="2-用例（Use-Cases）"><a href="#2-用例（Use-Cases）" class="headerlink" title="(2) 用例（Use Cases）"></a><strong>(2) 用例（Use Cases）</strong></h3><ul>
<li>用例表示应用程序的具体业务逻辑，例如：“用户下订单” 或 “计算订单折扣”。</li>
<li>这一层不应该依赖于数据库、UI 或其他外部服务，而应该是 <strong>纯粹的业务逻辑</strong>。</li>
<li>该层的主要目标是 <strong>封装应用程序的行为，并且对外提供清晰的接口</strong>。</li>
</ul>
<h3 id="3-接口适配器（Interface-Adapters）"><a href="#3-接口适配器（Interface-Adapters）" class="headerlink" title="(3) 接口适配器（Interface Adapters）"></a><strong>(3) 接口适配器（Interface Adapters）</strong></h3><ul>
<li>这一层包含将数据转换为应用层和外部系统（如数据库、Web API、UI）可以理解的格式的组件。</li>
<li>典型的组件包括：<ul>
<li><strong>Web 控制器（Controllers）</strong>：用于处理 HTTP 请求并调用相应的用例。</li>
<li><strong>数据库网关（Database Gateways）</strong>：将数据模型转换为数据库可存储的格式。</li>
<li><strong>Presenter 和 ViewModel</strong>：负责数据展示的转换，适用于 MVC/MVP 结构。</li>
</ul>
</li>
</ul>
<h3 id="4-框架-amp-驱动（Frameworks-amp-Drivers）"><a href="#4-框架-amp-驱动（Frameworks-amp-Drivers）" class="headerlink" title="(4) 框架 &amp; 驱动（Frameworks &amp; Drivers）"></a><strong>(4) 框架 &amp; 驱动（Frameworks &amp; Drivers）</strong></h3><ul>
<li>这一层是系统的最外层，包含具体的技术实现，如数据库、Web 框架、UI 框架等。</li>
<li>这一层应该是最容易更换的，不应该影响到核心业务逻辑。</li>
</ul>
<hr>
<h2 id="3-依赖规则（The-Dependency-Rule）"><a href="#3-依赖规则（The-Dependency-Rule）" class="headerlink" title="3. 依赖规则（The Dependency Rule）"></a><strong>3. 依赖规则（The Dependency Rule）</strong></h2><p>整洁架构最核心的原则是 <strong>依赖规则</strong>（The Dependency Rule），它规定：</p>
<blockquote>
<p><strong>代码的依赖关系必须始终指向高层，即核心业务逻辑，而不能依赖外部实现细节。</strong></p>
</blockquote>
<p>这意味着：</p>
<ul>
<li><strong>用例不能依赖 Web、数据库或 UI</strong>。</li>
<li><strong>实体不能依赖于用例</strong>，用例只能依赖于实体。</li>
<li><strong>框架、数据库、外部 API 只能依赖业务逻辑，而不能反过来</strong>。</li>
</ul>
<p>这一原则确保了：</p>
<ol>
<li><strong>业务逻辑的独立性</strong>：即使更换 UI、数据库，甚至更换整个框架，业务逻辑仍然能保持不变。</li>
<li><strong>可测试性</strong>：可以在不依赖外部框架的情况下，独立测试业务逻辑。</li>
</ol>
<hr>
<h2 id="4-整洁架构的典型示例"><a href="#4-整洁架构的典型示例" class="headerlink" title="4. 整洁架构的典型示例"></a><strong>4. 整洁架构的典型示例</strong></h2><p>Uncle Bob 在本章提供了一个“订单管理系统”的示例，以展示整洁架构的实践方式：</p>
<ol>
<li>用户提交订单<ul>
<li>用户点击按钮，前端 UI 层将 HTTP 请求发送到 Web 控制器。</li>
</ul>
</li>
<li>调用用例<ul>
<li>Web 控制器不包含业务逻辑，而是将请求传递给 <code>SubmitOrderUseCase</code>（应用层的用例）。</li>
</ul>
</li>
<li>执行业务逻辑<ul>
<li><code>SubmitOrderUseCase</code> 处理订单验证、库存检查、价格计算等核心逻辑。</li>
<li>用例层调用 <strong>数据库接口（Repository）</strong> 以存储订单数据，而不是直接操作数据库。</li>
</ul>
</li>
<li>适配器转换数据<ul>
<li>数据库接口由数据适配器实现，例如 <code>SQLOrderRepository</code>。</li>
<li>适配器将 <code>Order</code> 实体转换为数据库格式，并存储到数据库中。</li>
</ul>
</li>
<li>响应请求<ul>
<li><code>SubmitOrderUseCase</code> 返回执行结果，控制器将其格式化后返回给前端。</li>
</ul>
</li>
</ol>
<p>这样，系统的不同部分都有清晰的职责划分，并且数据库、UI、框架等外部技术都被隔离在业务逻辑之外。</p>
<hr>
<h2 id="5-整洁架构与其他架构的比较"><a href="#5-整洁架构与其他架构的比较" class="headerlink" title="5. 整洁架构与其他架构的比较"></a><strong>5. 整洁架构与其他架构的比较</strong></h2><p>Uncle Bob 认为整洁架构是对 <strong>MVC、洋葱架构、六边形架构（Hexagonal Architecture）</strong> 等架构模式的进一步提炼。</p>
<h3 id="整洁架构-vs-MVC"><a href="#整洁架构-vs-MVC" class="headerlink" title="整洁架构 vs. MVC"></a><strong>整洁架构 vs. MVC</strong></h3><table>
<thead>
<tr>
<th><strong>对比点</strong></th>
<th><strong>MVC</strong></th>
<th><strong>整洁架构</strong></th>
</tr>
</thead>
<tbody><tr>
<td>关注点分离</td>
<td>仅分离 UI 和业务逻辑，但控制器仍然依赖数据库</td>
<td>强制业务逻辑独立于 UI、数据库</td>
</tr>
<tr>
<td>依赖方向</td>
<td>Controller 可能依赖 Model</td>
<td>业务逻辑层永远不依赖于 UI 和数据库</td>
</tr>
<tr>
<td>适用范围</td>
<td>适用于前端和小型应用</td>
<td>适用于整个应用，包括微服务架构</td>
</tr>
</tbody></table>
<hr>
<h2 id="6-个人理解与思考"><a href="#6-个人理解与思考" class="headerlink" title="6. 个人理解与思考"></a><strong>6. 个人理解与思考</strong></h2><p>在实际开发中，我们经常看到业务逻辑被嵌入到控制器、数据库查询甚至 UI 代码中，导致代码难以维护。例如：</p>
<ul>
<li>在 <strong>Spring Boot 项目</strong> 中，很多人直接在 Controller 里操作数据库，这是 <strong>错误的架构设计</strong>。</li>
<li>在 <strong>前端 Vue/React 项目</strong> 中，一些开发者会在组件内写大量的业务逻辑，而不是封装在独立的 use case 里。</li>
</ul>
<p><strong>整洁架构的核心价值在于：</strong></p>
<ol>
<li><strong>业务逻辑与技术细节的分离</strong>：可以轻松更换 UI 框架、数据库，而不会影响核心功能。</li>
<li><strong>可测试性</strong>：可以在不启动数据库或 Web 服务器的情况下，直接测试业务逻辑。</li>
<li><strong>降低技术债务</strong>：通过严格的架构层次划分，避免代码变得难以维护。</li>
</ol>
<p>但 <strong>整洁架构也有一些挑战</strong>：</p>
<ul>
<li>需要额外的接口和抽象层，可能会增加短期开发成本。</li>
<li>初学者可能不习惯，觉得“麻烦”。</li>
<li>对小型项目来说，可能显得“过度设计”。</li>
</ul>
<p>然而，在 <strong>中大型系统</strong> 中，遵循整洁架构可以极大提升代码质量和维护性。例如：</p>
<ul>
<li><strong>电商系统</strong>：订单、支付、库存等核心业务逻辑应该独立于 UI 和数据库。</li>
<li><strong>银行系统</strong>：账户管理、交易处理等需要高度可测试和可维护的架构。</li>
</ul>
<hr>
<h5 id="7-结论"><a href="#7-结论" class="headerlink" title="7. 结论"></a><strong>7. 结论</strong></h5><p>整洁架构是 <strong>构建长期可维护软件系统的最佳实践之一</strong>。它强调 <strong>依赖倒置</strong>，确保业务逻辑独立于外部实现（如数据库、UI、框架），从而提高系统的灵活性、可扩展性和可测试性。</p>
<p>虽然短期内可能会增加一些额外的开发成本，但从长期来看，它能够 <strong>显著降低维护成本，延长软件的生命周期</strong>，是值得投资的一种架构模式。</p>
<h3 id="Chapter-23-Presenters-and-Humble-Objects（展现器与谦卑对象）"><a href="#Chapter-23-Presenters-and-Humble-Objects（展现器与谦卑对象）" class="headerlink" title="Chapter 23: Presenters and Humble Objects（展现器与谦卑对象）"></a><strong>Chapter 23: Presenters and Humble Objects（展现器与谦卑对象）</strong></h3><p>在 <em>Clean Architecture</em> 的第 23 章，Uncle Bob 介绍了 <strong>展现器（Presenters）</strong> 和 <strong>谦卑对象（Humble Objects）</strong> 这两个重要概念。这两个模式的核心目的是 <strong>保持业务逻辑的独立性</strong>，特别是在 UI 和数据层等容易变化的部分，以提高系统的可测试性和可维护性。</p>
<hr>
<h2 id="1-主要目标"><a href="#1-主要目标" class="headerlink" title="1. 主要目标"></a><strong>1. 主要目标</strong></h2><p>本章的主要目标是：</p>
<ol>
<li><strong>隔离 UI 逻辑与业务逻辑</strong>：确保业务逻辑不依赖于 UI 框架，从而提高可维护性。</li>
<li><strong>提高可测试性</strong>：通过引入 <strong>展现器</strong>（Presenter） 和 <strong>谦卑对象</strong>（Humble Objects），减少代码对外部依赖的耦合，使得业务逻辑可以进行单元测试，而无需依赖 UI 或数据库。</li>
</ol>
<hr>
<h2 id="2-展现器（Presenters）"><a href="#2-展现器（Presenters）" class="headerlink" title="2. 展现器（Presenters）"></a><strong>2. 展现器（Presenters）</strong></h2><h3 id="什么是展现器？"><a href="#什么是展现器？" class="headerlink" title="什么是展现器？"></a><strong>什么是展现器？</strong></h3><ul>
<li>Presenter 负责 <strong>将业务逻辑的结果转换为 UI 友好的格式</strong>，然后传递给视图层（View）。</li>
<li>它不应该直接依赖 UI 组件，而应该输出 <strong>原始数据</strong>（如字符串、数值、布尔值等），让 UI 组件来决定如何呈现。</li>
<li>它通常与 <strong>MVP（Model-View-Presenter）架构</strong> 相关，替代了传统的 MVC 结构中的控制器（Controller）。</li>
</ul>
<h3 id="展现器的作用"><a href="#展现器的作用" class="headerlink" title="展现器的作用"></a><strong>展现器的作用</strong></h3><p>在很多应用中，UI 组件不仅负责显示数据，还会承担一部分业务逻辑，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginClicked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String username = usernameEditText.getText().toString();</span><br><span class="line">    String password = passwordEditText.getText().toString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (username.isEmpty() || password.isEmpty()) &#123;</span><br><span class="line">        showErrorMessage(<span class="string">&quot;用户名或密码不能为空&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        authenticate(username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法的问题是：</p>
<ul>
<li><strong>业务逻辑（表单验证）与 UI 绑定在一起</strong>，如果 UI 需要变更（比如从 Android 切换到 Web），代码就无法复用。</li>
<li><strong>难以测试</strong>，因为这段代码必须运行在 UI 线程上，无法进行单元测试。</li>
</ul>
<p><strong>使用 Presenter 之后，代码可以变成这样：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LoginView view;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginPresenter</span><span class="params">(LoginView view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.view = view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginClicked</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username.isEmpty() || password.isEmpty()) &#123;</span><br><span class="line">            view.showErrorMessage(<span class="string">&quot;用户名或密码不能为空&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view.showLoading();</span><br><span class="line">            <span class="comment">// 调用业务逻辑</span></span><br><span class="line">            <span class="keyword">boolean</span> success = authService.authenticate(username, password);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                view.showSuccessMessage(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                view.showErrorMessage(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 UI 只需要调用 <code>presenter.onLoginClicked(username, password)</code>，所有业务逻辑都在 <code>Presenter</code> 中完成，而 UI 只关注展示。</p>
<h3 id="Presenter-的优势"><a href="#Presenter-的优势" class="headerlink" title="Presenter 的优势"></a><strong>Presenter 的优势</strong></h3><ol>
<li><strong>解耦 UI 和业务逻辑</strong>：如果需要修改 UI，只需修改 <code>LoginView</code>，而不会影响 <code>LoginPresenter</code>。</li>
<li><strong>可测试性提高</strong>：<code>LoginPresenter</code> 可以通过 <strong>单元测试</strong> 进行测试，而不需要依赖 UI 框架。</li>
<li><strong>提高代码复用性</strong>：Presenter 层可以在不同 UI（如 Web、移动端）之间共享。</li>
</ol>
<hr>
<h2 id="3-谦卑对象（Humble-Objects）"><a href="#3-谦卑对象（Humble-Objects）" class="headerlink" title="3. 谦卑对象（Humble Objects）"></a><strong>3. 谦卑对象（Humble Objects）</strong></h2><h3 id="什么是谦卑对象？"><a href="#什么是谦卑对象？" class="headerlink" title="什么是谦卑对象？"></a><strong>什么是谦卑对象？</strong></h3><ul>
<li><strong>Humble Objects（谦卑对象）是一种专门用于隔离难以测试代码的模式</strong>。</li>
<li>主要应用于 <strong>UI 组件、数据库操作、外部 API 调用</strong> 等依赖外部环境的代码，使得业务逻辑可以在没有这些依赖的情况下进行测试。</li>
</ul>
<h3 id="为什么需要谦卑对象？"><a href="#为什么需要谦卑对象？" class="headerlink" title="为什么需要谦卑对象？"></a><strong>为什么需要谦卑对象？</strong></h3><p>在实际开发中，有些代码很难单元测试，比如：</p>
<ol>
<li><strong>UI 代码（如 Android Activity、iOS ViewController）</strong></li>
<li><strong>数据库操作（如 DAO、Repository）</strong></li>
<li><strong>网络请求（如 Retrofit、HTTP Client）</strong></li>
</ol>
<p>如果这些代码直接与业务逻辑耦合，就会导致 <strong>测试难度增加</strong>，因为：</p>
<ul>
<li>需要运行 UI 或数据库环境才能测试（增加测试成本）。</li>
<li>难以编写自动化单元测试。</li>
</ul>
<h3 id="谦卑对象的做法"><a href="#谦卑对象的做法" class="headerlink" title="谦卑对象的做法"></a><strong>谦卑对象的做法</strong></h3><p><strong>核心思想</strong>：把不可测试的代码拆分出去，只保留最少量的逻辑，并将复杂逻辑转移到可测试的对象中。</p>
<h4 id="示例：重构-UI-逻辑"><a href="#示例：重构-UI-逻辑" class="headerlink" title="示例：重构 UI 逻辑"></a><strong>示例：重构 UI 逻辑</strong></h4><p>假设我们有一个 Android Activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line">        </span><br><span class="line">        Button loginButton = findViewById(R.id.login_button);</span><br><span class="line">        loginButton.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            String username = getUsername();</span><br><span class="line">            String password = getPassword();</span><br><span class="line">            <span class="keyword">if</span> (username.isEmpty() || password.isEmpty()) &#123;</span><br><span class="line">                showErrorMessage(<span class="string">&quot;用户名或密码不能为空&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                authenticate(username, password);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码的<strong>问题</strong>：</p>
<ol>
<li>UI 和业务逻辑混杂在一起，难以测试。</li>
<li>业务逻辑（如表单验证）必须在 UI 线程执行，降低了灵活性。</li>
</ol>
<p><strong>使用谦卑对象重构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">LoginView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LoginPresenter presenter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_login);</span><br><span class="line"></span><br><span class="line">        presenter = <span class="keyword">new</span> LoginPresenter(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Button loginButton = findViewById(R.id.login_button);</span><br><span class="line">        loginButton.setOnClickListener(v -&gt; presenter.onLoginClicked(getUsername(), getPassword()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showErrorMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, message, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>现在 LoginActivity 只是一个“谦卑对象”</strong>：</p>
<ul>
<li><strong>它不包含业务逻辑</strong>，只是一个 UI 适配器。</li>
<li><strong>Presenter 处理所有业务逻辑</strong>，可以单独测试。</li>
</ul>
<hr>
<h2 id="4-Presenter-amp-Humble-Object-的结合"><a href="#4-Presenter-amp-Humble-Object-的结合" class="headerlink" title="4. Presenter &amp; Humble Object 的结合"></a><strong>4. Presenter &amp; Humble Object 的结合</strong></h2><p>在整洁架构中，Presenter 和 Humble Objects 可以一起使用：</p>
<ul>
<li><strong>Presenter 负责业务逻辑，不依赖 UI</strong>。</li>
<li><strong>Humble Object 作为 UI 层的适配器，仅提供最少的逻辑</strong>。</li>
</ul>
<p>这样，业务逻辑可以独立于 UI 进行测试，UI 也可以随时替换而不影响核心逻辑。</p>
<hr>
<h2 id="5-个人理解-3"><a href="#5-个人理解-3" class="headerlink" title="5. 个人理解"></a><strong>5. 个人理解</strong></h2><h3 id="1-Presenter-在实际项目中的应用"><a href="#1-Presenter-在实际项目中的应用" class="headerlink" title="1. Presenter 在实际项目中的应用"></a><strong>1. Presenter 在实际项目中的应用</strong></h3><ul>
<li>在 <strong>前端</strong>，Presenter 类似于 <strong>ViewModel（MVVM架构）</strong>，可以用于 Vue、React、Android 等项目中。</li>
<li>在 <strong>后端</strong>，Presenter 可以用于 API 层，将业务逻辑与 Web 框架（如 Spring、Express）解耦。</li>
</ul>
<h3 id="2-谦卑对象适用于哪些场景？"><a href="#2-谦卑对象适用于哪些场景？" class="headerlink" title="2. 谦卑对象适用于哪些场景？"></a><strong>2. 谦卑对象适用于哪些场景？</strong></h3><ul>
<li><p>适用于 </p>
<p>难以测试的代码</p>
<p>，例如：</p>
<ul>
<li>数据库访问（如 <code>Hibernate Repository</code>）</li>
<li>UI 组件（如 Android <code>Activity</code>）</li>
<li>网络请求（如 <code>Retrofit</code>）</li>
</ul>
</li>
</ul>
<p><strong>通过谦卑对象，将难测的代码与业务逻辑隔离，使得业务逻辑可以独立测试</strong>。</p>
<hr>
<h5 id="6-结论-3"><a href="#6-结论-3" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h5><p>第 23 章强调了 <strong>如何解耦 UI 逻辑和业务逻辑</strong>，以提高可测试性和可维护性：</p>
<ul>
<li><strong>使用 Presenter 处理 UI 逻辑，避免业务逻辑与 UI 框架耦合</strong>。</li>
<li><strong>使用 Humble Object 分离难以测试的代码，使核心逻辑可单元测试</strong>。</li>
</ul>
<p>这些模式对于 <strong>构建长期可维护的软件系统</strong> 至关重要。</p>
<h3 id="Partial-Boundaries（部分边界）"><a href="#Partial-Boundaries（部分边界）" class="headerlink" title="Partial Boundaries（部分边界）"></a>Partial Boundaries（部分边界）</h3><p>在 <em>Clean Architecture</em> 的第 24 章，Uncle Bob 介绍了 <strong>部分边界（Partial Boundaries）</strong> 的概念，并探讨了在实际开发中，如何在架构设计中做出权衡，决定哪些边界应该被严格遵循，哪些边界可以暂时“跳过”或弱化。</p>
<hr>
<h2 id="1-什么是部分边界？"><a href="#1-什么是部分边界？" class="headerlink" title="1. 什么是部分边界？"></a><strong>1. 什么是部分边界？</strong></h2><p>在软件架构中，<strong>边界（Boundaries）</strong> 是用来 <strong>隔离不同的模块、层或服务</strong> 的，以提高可维护性、可扩展性和可测试性。然而，在实际开发中，严格遵守所有边界可能会导致：</p>
<ul>
<li><strong>架构过度复杂</strong>：每个模块都完全隔离，增加了开发成本。</li>
<li><strong>短期开发效率低</strong>：为了满足架构要求，需要额外的抽象层，可能会拖慢初始开发速度。</li>
</ul>
<p>因此，Uncle Bob 提出了 <strong>部分边界</strong> 的概念，即 <strong>在保持架构清晰的前提下，适当调整某些边界，以平衡开发效率和架构完整性</strong>。</p>
<h3 id="什么时候应该使用部分边界？"><a href="#什么时候应该使用部分边界？" class="headerlink" title="什么时候应该使用部分边界？"></a><strong>什么时候应该使用部分边界？</strong></h3><ol>
<li><p>项目初期或小型项目</p>
<p>：</p>
<ul>
<li>过早地拆分出所有边界可能会增加不必要的复杂性，可以等系统发展到一定规模后再调整。</li>
</ul>
</li>
<li><p>某些模块对架构的影响较小</p>
<p>：</p>
<ul>
<li>例如，一些简单的工具类或 UI 适配层，并不需要严格的架构隔离。</li>
</ul>
</li>
<li><p>性能优化</p>
<p>：</p>
<ul>
<li>在某些情况下，层与层之间的调用可能会影响性能，可以考虑弱化边界。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-跳过最后一步（Skip-the-Last-Step）"><a href="#2-跳过最后一步（Skip-the-Last-Step）" class="headerlink" title="2. 跳过最后一步（Skip the Last Step）"></a><strong>2. 跳过最后一步（Skip the Last Step）</strong></h2><p>Uncle Bob 提出了一个<strong>架构设计的常见技巧</strong>：<strong>跳过最后一步</strong>，即 <strong>暂时不做最后的抽象，等到真的需要时再补上</strong>。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>在传统的分层架构中，我们通常会创建如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Controller → Service → Repository → Database</span><br></pre></td></tr></table></figure>

<p>但在项目初期，可能 <strong>Service 层</strong> 只是一个简单的转发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>UserService</code> 实际上并没有提供太多额外的逻辑，而只是简单地调用 <code>UserRepository</code>，这时，我们可以 <strong>暂时跳过 Service 层</strong>，直接在 Controller 里调用 <code>UserRepository</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等到未来 <code>UserService</code> 需要额外的逻辑（比如权限检查、事务管理等）时，再引入 <code>Service</code> 层。</p>
<h3 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a><strong>关键思想</strong></h3><ul>
<li>不是所有的边界都需要在项目一开始就建立，可以在真正需要时再进行抽象。</li>
<li>但<strong>需要有意识地做出权衡</strong>，而不是完全忽略架构设计，否则会导致代码变得难以维护。</li>
</ul>
<hr>
<h2 id="3-一维边界（One-Dimensional-Boundaries）"><a href="#3-一维边界（One-Dimensional-Boundaries）" class="headerlink" title="3. 一维边界（One-Dimensional Boundaries）"></a><strong>3. 一维边界（One-Dimensional Boundaries）</strong></h2><p>在部分边界的概念下，我们可以 <strong>仅在某些特定方向上引入边界，而在其他方向上保持灵活性</strong>，这就是 <strong>一维边界（One-Dimensional Boundaries）</strong>。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设我们有一个电商系统，包含以下几个模块：</p>
<ul>
<li><strong>订单管理（Order Management）</strong></li>
<li><strong>库存管理（Inventory Management）</strong></li>
<li><strong>支付系统（Payment System）</strong></li>
</ul>
<p>在一个严格的微服务架构下，这三个模块应该完全分离，并通过 API 通信。但如果系统还处于早期，完全拆分可能会带来额外的开发成本，因此，我们可以：</p>
<ol>
<li><strong>保持代码逻辑独立</strong>，但仍然运行在同一个单体应用（Monolith）中。</li>
<li><strong>只在核心业务上引入边界</strong>，比如确保支付逻辑不依赖于订单系统的实现细节，而是通过接口交互。</li>
</ol>
<p><strong>这样，我们建立了“部分边界”</strong>：</p>
<ul>
<li><strong>核心业务（支付系统）是独立的，不能直接访问订单管理的内部实现</strong>。</li>
<li><strong>订单和库存管理可以暂时不分离，未来需要时再拆分</strong>。</li>
</ul>
<h3 id="关键思想-1"><a href="#关键思想-1" class="headerlink" title="关键思想"></a><strong>关键思想</strong></h3><ul>
<li><strong>边界的拆分可以逐步进行，而不一定要一步到位。</strong></li>
<li><strong>优先拆分关键业务的边界，而次要部分可以暂时保持松散耦合。</strong></li>
</ul>
<hr>
<h2 id="4-外观模式（Facades）"><a href="#4-外观模式（Facades）" class="headerlink" title="4. 外观模式（Facades）"></a><strong>4. 外观模式（Facades）</strong></h2><p>为了减少部分边界带来的复杂性，可以使用 <strong>外观模式（Facade Pattern）</strong>，即 <strong>提供一个简单的接口来封装复杂的内部实现</strong>。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设 <code>OrderService</code> 需要和 <code>InventoryService</code>、<code>PaymentService</code> 交互：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryService inventoryService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderService</span><span class="params">(InventoryService inventoryService, PaymentService paymentService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inventoryService = inventoryService;</span><br><span class="line">        <span class="keyword">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!inventoryService.reserveStock(order)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!paymentService.charge(order)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里：</p>
<ul>
<li><strong>OrderService 依赖了多个服务</strong>，如果未来拆分微服务，可能会导致多个 API 调用。</li>
<li><strong>我们可以创建一个 Facade（外观）来简化 OrderService 的依赖</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFacade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderFacade</span><span class="params">(OrderService orderService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderService = orderService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">placeOrder</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.placeOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样：</p>
<ul>
<li><strong>外部调用者只需要依赖 OrderFacade，而不需要关心 OrderService 的具体实现</strong>。</li>
<li><strong>未来如果要拆分架构，我们只需要调整 Facade 的实现，而不会影响调用方</strong>。</li>
</ul>
<hr>
<h2 id="5-个人理解-4"><a href="#5-个人理解-4" class="headerlink" title="5. 个人理解"></a><strong>5. 个人理解</strong></h2><h3 id="1-“部分边界”-vs-“过度抽象”"><a href="#1-“部分边界”-vs-“过度抽象”" class="headerlink" title="1. “部分边界” vs. “过度抽象”"></a><strong>1. “部分边界” vs. “过度抽象”</strong></h3><ul>
<li><p>许多开发者喜欢在一开始就建立完整的分层结构，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Controller → Service → Repository → DTO → Entity</span><br></pre></td></tr></table></figure>

<p>但有时候，</p>
<p>过早的抽象会导致不必要的复杂性</p>
<p>。Uncle Bob 的观点是：</p>
<ul>
<li><strong>如果某个层只是简单地转发调用，那么它可能是不必要的</strong>。</li>
<li><strong>等到它真正需要时，再进行抽象</strong>，避免一开始就引入过多的“架构仪式感”。</li>
</ul>
</li>
</ul>
<h3 id="2-“部分边界”-vs-“技术债务”"><a href="#2-“部分边界”-vs-“技术债务”" class="headerlink" title="2. “部分边界” vs. “技术债务”"></a><strong>2. “部分边界” vs. “技术债务”</strong></h3><ul>
<li>“部分边界” ≠ “不做架构设计”。</li>
<li><strong>有意识地选择哪些边界需要严格遵守，哪些边界可以暂时忽略，是一种架构决策，而不是技术债务</strong>。</li>
<li><strong>技术债务是无意识的妥协，而部分边界是有意识的权衡</strong>。</li>
</ul>
<h3 id="3-适用于什么场景？"><a href="#3-适用于什么场景？" class="headerlink" title="3. 适用于什么场景？"></a><strong>3. 适用于什么场景？</strong></h3><ul>
<li><strong>初创公司/小型项目</strong>：避免过早拆分系统，保持灵活性。</li>
<li><strong>性能优化</strong>：在特定情况下，减少层与层之间的调用开销。</li>
<li><strong>渐进式架构演进</strong>：随着系统的增长，逐步拆分边界，而不是一开始就过度架构化。</li>
</ul>
<hr>
<h2 id="6-结论-4"><a href="#6-结论-4" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h2><p>第 24 章的核心思想是：</p>
<ul>
<li><strong>并非所有的架构边界都需要严格执行，可以根据业务需求进行灵活调整</strong>。</li>
<li><strong>通过“跳过最后一步”原则，避免过早抽象带来的架构复杂性</strong>。</li>
<li><strong>使用 Facade 等模式，在保持灵活性的同时，不破坏架构完整性</strong>。</li>
</ul>
<p><strong>整洁架构并不是死板的规则，而是一种平衡灵活性和结构性的艺术！</strong> 🎨</p>
<h3 id="Layers-and-Boundaries（层与边界）"><a href="#Layers-and-Boundaries（层与边界）" class="headerlink" title="Layers and Boundaries（层与边界）"></a>Layers and Boundaries（层与边界）</h3><p>在 <em>Clean Architecture</em> 的第 25 章，Uncle Bob 进一步探讨了 <strong>软件架构中的层次（Layers）和边界（Boundaries）</strong>，并强调了如何 <strong>正确地组织代码，以确保架构的清晰性、可维护性和可扩展性</strong>。</p>
<p>这一章的核心思想是：</p>
<ul>
<li><strong>通过层次划分，隔离不同的关注点</strong>，避免代码耦合导致的维护成本上升。</li>
<li><strong>通过边界控制依赖方向</strong>，确保业务逻辑独立于技术实现，使系统更易于测试和扩展。</li>
<li><strong>正确地跨越边界</strong>，确保数据和控制流在不同层之间合理地流动。</li>
</ul>
<hr>
<h2 id="1-为什么要使用层和边界？"><a href="#1-为什么要使用层和边界？" class="headerlink" title="1. 为什么要使用层和边界？"></a><strong>1. 为什么要使用层和边界？</strong></h2><p>在软件架构中，我们经常使用“分层”（Layering）来组织代码。分层的主要目的是：</p>
<ol>
<li><strong>清晰职责划分</strong>：不同的层负责不同的任务，比如数据访问、业务逻辑、UI 展示等。</li>
<li><strong>降低耦合，提高可维护性</strong>：如果某一层的实现需要变更，不会影响其他层。</li>
<li><strong>提高可测试性</strong>：通过分层，可以更容易地对业务逻辑进行单元测试，而无需依赖数据库或 UI。</li>
</ol>
<p><strong>但问题是：</strong></p>
<ul>
<li>许多开发者在设计分层架构时，并没有清晰地定义 <strong>层与层之间的边界</strong>，导致依赖关系混乱，降低了架构的灵活性。</li>
<li>例如，在许多 Web 应用中，Controller 层直接操作数据库（Repository），而不是调用业务逻辑（Use Case），这会导致业务逻辑分散在各个 Controller 中，难以维护和复用。</li>
</ul>
<p><strong>Uncle Bob 认为，良好的架构不仅需要分层，还需要明确的边界（Boundaries），确保每一层的职责清晰，依赖关系合理。</strong></p>
<hr>
<h2 id="2-典型的软件分层"><a href="#2-典型的软件分层" class="headerlink" title="2. 典型的软件分层"></a><strong>2. 典型的软件分层</strong></h2><p>在整洁架构（Clean Architecture）中，系统通常被划分为以下 <strong>四个层级</strong>（从核心到外围）：</p>
<h3 id="（1）实体层（Entities）"><a href="#（1）实体层（Entities）" class="headerlink" title="（1）实体层（Entities）"></a><strong>（1）实体层（Entities）</strong></h3><ul>
<li>代表核心业务规则，<strong>不依赖于任何技术实现</strong>（如数据库、UI、Web 框架）。</li>
<li>例如，<code>Order</code>、<code>User</code>、<code>Product</code> 等业务对象应该定义在这一层，并且只包含业务规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> paid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markAsPaid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paid = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>这些实体可以在不同的应用程序中复用（例如，在 Web 和移动端共享）。</li>
<li><strong>不应该依赖数据库、框架或外部库</strong>，而是完全独立的业务逻辑。</li>
</ul>
<hr>
<h3 id="（2）用例层（Use-Cases-Application-Layer）"><a href="#（2）用例层（Use-Cases-Application-Layer）" class="headerlink" title="（2）用例层（Use Cases / Application Layer）"></a><strong>（2）用例层（Use Cases / Application Layer）</strong></h3><ul>
<li>这一层封装了应用程序的业务逻辑，<strong>但不会依赖于外部技术（如数据库、UI）</strong>。</li>
<li>例如，在订单管理系统中，”下订单” 就是一个用例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCase</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PlaceOrderUseCase</span><span class="params">(OrderRepository orderRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderRepository = orderRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>这一层是 <strong>业务逻辑的真正所在</strong>，也是系统最核心的部分。</li>
<li><strong>它只能依赖“实体层”，而不能依赖数据库、UI 或外部服务</strong>。</li>
</ul>
<hr>
<h3 id="（3）接口适配层（Interface-Adapters）"><a href="#（3）接口适配层（Interface-Adapters）" class="headerlink" title="（3）接口适配层（Interface Adapters）"></a><strong>（3）接口适配层（Interface Adapters）</strong></h3><ul>
<li>负责 <strong>将数据格式转换成不同的表现形式</strong>，适配业务逻辑与外部技术之间的差异。</li>
<li>典型组件包括：<ul>
<li><strong>Controller（用于 Web 端）</strong></li>
<li><strong>Presenter / ViewModel（用于 UI 层）</strong></li>
<li><strong>Repository（用于数据库访问）</strong></li>
</ul>
</li>
</ul>
<p>例如，Spring Boot 的 Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/orders&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderController</span><span class="params">(PlaceOrderUseCase placeOrderUseCase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.placeOrderUseCase = placeOrderUseCase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">placeOrder</span><span class="params">(<span class="meta">@RequestBody</span> OrderRequest request)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order(request.getOrderId(), request.getItems());</span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="string">&quot;Order placed successfully&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><strong>这一层依赖于业务逻辑层（Use Case），但不能反过来</strong>。</li>
<li><strong>这一层的实现可能会变更</strong>（比如 UI 可能从 Web 迁移到 Mobile），但业务逻辑可以保持不变。</li>
</ul>
<hr>
<h3 id="（4）框架-amp-驱动层（Frameworks-amp-Drivers）"><a href="#（4）框架-amp-驱动层（Frameworks-amp-Drivers）" class="headerlink" title="（4）框架 &amp; 驱动层（Frameworks &amp; Drivers）"></a><strong>（4）框架 &amp; 驱动层（Frameworks &amp; Drivers）</strong></h3><ul>
<li><p>这一层是 </p>
<p>所有外部技术的集合</p>
<p>，包括：</p>
<ul>
<li>数据库（如 MySQL, MongoDB）</li>
<li>Web 框架（如 Spring, Express）</li>
<li>UI 框架（如 React, Angular）</li>
</ul>
</li>
</ul>
<p>例如，Spring 的 Repository 组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaOrderRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderJpaRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JpaOrderRepository</span><span class="params">(OrderJpaRepository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        repository.save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li><strong>这一层的代码最容易变更</strong>，因为技术选型可能会发生变化。</li>
<li><strong>业务逻辑（Use Case）不应该依赖于具体的数据库实现</strong>，而是依赖抽象的 <code>OrderRepository</code> 接口。</li>
</ul>
<hr>
<h2 id="3-依赖方向"><a href="#3-依赖方向" class="headerlink" title="3. 依赖方向"></a><strong>3. 依赖方向</strong></h2><p>Uncle Bob 强调了 <strong>依赖方向（Dependency Rule）</strong>：</p>
<ul>
<li><strong>依赖只能从外向内流动</strong>，即 <strong>外层依赖内层，内层不依赖外层</strong>。</li>
<li><strong>实体层（Entities）绝对不能依赖任何其他层</strong>。</li>
<li><strong>用例层（Use Case）可以依赖实体层，但不能依赖 UI、数据库等技术实现</strong>。</li>
<li><strong>所有外部技术（数据库、Web 框架等）必须通过接口适配层进行抽象</strong>，防止对具体技术的依赖扩散到业务逻辑中。</li>
</ul>
<p>如果我们把整洁架构画成 <strong>同心圆</strong>，依赖关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Entities] ← [Use Cases] ← [Interface Adapters] ← [Frameworks &amp; Drivers]</span><br></pre></td></tr></table></figure>

<p>这确保了：</p>
<ul>
<li><strong>业务逻辑不会被技术实现限制</strong>，可以自由更换数据库、UI 框架、Web 框架等。</li>
<li><strong>系统更容易测试</strong>，因为业务逻辑不依赖外部框架，可以独立测试。</li>
</ul>
<hr>
<h2 id="4-现实世界的权衡"><a href="#4-现实世界的权衡" class="headerlink" title="4. 现实世界的权衡"></a><strong>4. 现实世界的权衡</strong></h2><p>虽然 <strong>严格分层</strong> 能提高系统的可维护性，但它也可能带来 <strong>额外的开发成本</strong>。<br> 因此，在实际开发中，我们需要 <strong>权衡以下因素</strong>：</p>
<ol>
<li><strong>避免过度抽象</strong>：如果某一层只是简单地调用另一层，可能可以省略（如前面提到的部分边界）。</li>
<li><strong>业务复杂度 vs. 开发效率</strong>：如果业务逻辑较少，可能不需要严格的架构划分，但如果系统复杂，清晰的分层可以降低长期成本。</li>
<li><strong>逐步演进架构</strong>：可以先从松耦合的单体架构（Monolith）开始，随着需求变化逐步拆分不同的层和模块。</li>
</ol>
<hr>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a><strong>5. 结论</strong></h2><ul>
<li><strong>分层架构可以提高系统的可维护性和可测试性</strong>，但需要明确每一层的职责和边界。</li>
<li><strong>依赖方向必须从外向内，业务逻辑不能依赖外部技术</strong>，以保证核心逻辑的独立性。</li>
<li><strong>在实际项目中，架构应该是渐进演化的，不需要一开始就过度抽象</strong>，而是根据业务需求逐步优化。</li>
</ul>
<p>整洁架构的核心目标是 <strong>让代码保持灵活性，使其能适应未来的变化</strong>，这一点对于构建长期可维护的软件系统至关重要。 🚀</p>
<h3 id="The-Main-Component（主组件）"><a href="#The-Main-Component（主组件）" class="headerlink" title="The Main Component（主组件）"></a>The Main Component（主组件）</h3><h1 id="第-26-章：The-Main-Component（主组件）"><a href="#第-26-章：The-Main-Component（主组件）" class="headerlink" title="第 26 章：The Main Component（主组件）"></a><strong>第 26 章：The Main Component（主组件）</strong></h1><p>在 <em>Clean Architecture</em> 的第 26 章，Uncle Bob 讨论了 <strong>主组件（Main Component）</strong> 的概念，并解释了 <strong>如何正确组织和管理系统的启动流程</strong>。</p>
<p>这一章的核心思想是：</p>
<ul>
<li><strong>应用程序的“Main”组件是所有细节的汇聚点</strong>，但它本身应该保持尽可能的简单。</li>
<li><strong>架构的核心逻辑不应该依赖于“Main”组件，而应该由“Main”组件来组装和初始化所有依赖项</strong>。</li>
<li><strong>“Main”组件本质上是一个“细节”，它的变化不应该影响业务逻辑</strong>。</li>
</ul>
<hr>
<h2 id="1-什么是“主组件”？"><a href="#1-什么是“主组件”？" class="headerlink" title="1. 什么是“主组件”？"></a><strong>1. 什么是“主组件”？</strong></h2><p>在任何软件系统中，都会有一个 <strong>入口点（Entry Point）</strong>，用于启动整个应用。这个入口通常被称为“Main”组件，例如：</p>
<ul>
<li><strong>桌面应用</strong>：<code>main()</code> 方法</li>
<li><strong>Web 应用</strong>：<code>Servlet</code>、<code>Spring Boot</code> 的 <code>main()</code> 方法</li>
<li><strong>Android 应用</strong>：<code>Application</code> 类</li>
<li><strong>微服务</strong>：<code>Service</code> 入口</li>
</ul>
<p>在很多应用中，<code>Main</code> 组件不仅负责启动应用，还会：</p>
<ol>
<li><strong>配置依赖关系</strong>（例如，依赖注入）</li>
<li><strong>初始化框架</strong>（如 Spring、Django）</li>
<li><strong>加载配置文件</strong></li>
<li><strong>启动服务</strong>（如 HTTP 服务器、任务调度器）</li>
</ol>
<p><strong>问题是：</strong><br> 如果 <code>Main</code> 组件直接依赖业务逻辑，并且业务逻辑又依赖 <code>Main</code> 组件，那么整个架构就会变得紧密耦合，难以维护。</p>
<hr>
<h2 id="2-Main-组件的正确职责"><a href="#2-Main-组件的正确职责" class="headerlink" title="2. Main 组件的正确职责"></a><strong>2. Main 组件的正确职责</strong></h2><p>Uncle Bob 认为，<code>Main</code> 组件应该遵循以下规则：</p>
<ul>
<li><strong>它应该是“最终的细节”</strong>：即它是一个 <strong>基础设施细节</strong>，不应该影响系统的核心业务逻辑。</li>
<li><strong>它应该只负责“组装”应用，而不包含业务逻辑</strong>：即它的主要任务是 <strong>创建对象并连接它们</strong>。</li>
<li><strong>它应该遵循依赖倒置原则（DIP）</strong>：即 <strong>业务逻辑不应该依赖 Main 组件，而 Main 组件应该依赖业务逻辑</strong>。</li>
</ul>
<p>在整洁架构中，<code>Main</code> 组件的作用就像是<strong>组装工厂（Assembly Factory）</strong>，它负责把所有组件连接在一起，然后启动应用。</p>
<hr>
<h2 id="3-依赖倒置：Main-依赖业务，而不是反过来"><a href="#3-依赖倒置：Main-依赖业务，而不是反过来" class="headerlink" title="3. 依赖倒置：Main 依赖业务，而不是反过来"></a><strong>3. 依赖倒置：Main 依赖业务，而不是反过来</strong></h2><p>在许多传统的应用中，依赖关系是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">业务逻辑 → 数据库 → Main 组件</span><br></pre></td></tr></table></figure>

<p>但是，整洁架构的目标是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Main 组件 → 业务逻辑（Use Cases） → 数据库（Repository）</span><br></pre></td></tr></table></figure>

<p>即：</p>
<ul>
<li><code>Main</code> 组件依赖于 <strong>业务逻辑（Use Cases）</strong> 和 <strong>基础设施（Database, UI, API）</strong>。</li>
<li>业务逻辑（Use Cases）<strong>不应该依赖</strong> <code>Main</code> 组件。</li>
</ul>
<hr>
<h2 id="4-典型的-Main-组件实现"><a href="#4-典型的-Main-组件实现" class="headerlink" title="4. 典型的 Main 组件实现"></a><strong>4. 典型的 Main 组件实现</strong></h2><h3 id="不推荐的方式"><a href="#不推荐的方式" class="headerlink" title="不推荐的方式"></a><strong>不推荐的方式</strong></h3><p>在很多应用中，开发者会把业务逻辑直接写在 <code>Main</code> 组件里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrderService orderService = <span class="keyword">new</span> OrderService();</span><br><span class="line">        orderService.placeOrder(<span class="keyword">new</span> Order());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的问题是：</p>
<ol>
<li><strong>Main 组件直接依赖业务逻辑</strong>，导致 <code>OrderService</code> 不能被单独测试。</li>
<li>如果 <code>OrderService</code> 发生变化，<code>Main</code> 也必须修改，导致代码耦合。</li>
</ol>
<h3 id="推荐的方式"><a href="#推荐的方式" class="headerlink" title="推荐的方式"></a><strong>推荐的方式</strong></h3><p>在整洁架构中，<code>Main</code> 组件的作用是 <strong>组装对象</strong>，而不是执行业务逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OrderRepository orderRepository = <span class="keyword">new</span> DatabaseOrderRepository();</span><br><span class="line">        PaymentService paymentService = <span class="keyword">new</span> StripePaymentService();</span><br><span class="line">        </span><br><span class="line">        PlaceOrderUseCase placeOrderUseCase = <span class="keyword">new</span> PlaceOrderUseCase(orderRepository, paymentService);</span><br><span class="line">        </span><br><span class="line">        OrderController orderController = <span class="keyword">new</span> OrderController(placeOrderUseCase);</span><br><span class="line">        orderController.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的好处：</p>
<ul>
<li><strong>Main 组件只是负责组装，不包含业务逻辑</strong>。</li>
<li><strong>业务逻辑（Use Case）不依赖 Main</strong>，可以在其他地方（如单元测试）独立使用。</li>
<li><strong>如果未来需要更换数据库或支付方式，只需要修改 Main 组件，而不影响业务逻辑</strong>。</li>
</ul>
<hr>
<h2 id="5-Main-组件与依赖注入（DI）"><a href="#5-Main-组件与依赖注入（DI）" class="headerlink" title="5. Main 组件与依赖注入（DI）"></a><strong>5. Main 组件与依赖注入（DI）</strong></h2><p>在现代应用中，我们通常使用 <strong>依赖注入（Dependency Injection, DI）</strong> 框架（如 Spring、Dagger）来简化对象的组装。</p>
<p>在 Spring Boot 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 通过 <code>@ComponentScan</code> 自动扫描 <code>@Service</code>、<code>@Repository</code> 等注解，替代了手动创建对象的过程。</p>
<p>在 Dagger（Android DI 框架）中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppComponent</span> </span>&#123;</span><br><span class="line">    <span class="function">OrderController <span class="title">getOrderController</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AppComponent appComponent = DaggerAppComponent.create();</span><br><span class="line">        OrderController orderController = appComponent.getOrderController();</span><br><span class="line">        orderController.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们把依赖创建的工作交给 DI 框架，而 <code>Main</code> 组件依然保持 <strong>只负责组装，不包含业务逻辑</strong>。</p>
<hr>
<h2 id="6-Main-组件的现实应用"><a href="#6-Main-组件的现实应用" class="headerlink" title="6. Main 组件的现实应用"></a><strong>6. Main 组件的现实应用</strong></h2><p>在不同类型的应用中，<code>Main</code> 组件的表现形式有所不同：</p>
<table>
<thead>
<tr>
<th>应用类型</th>
<th>Main 组件的形式</th>
<th>主要职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>桌面应用</strong></td>
<td><code>main()</code> 方法</td>
<td>初始化 UI，加载配置</td>
</tr>
<tr>
<td><strong>Web 应用</strong></td>
<td><code>Spring Boot</code>、<code>Django App</code></td>
<td>启动 Web 服务器，配置路由</td>
</tr>
<tr>
<td><strong>移动应用</strong></td>
<td><code>Application</code> 类</td>
<td>初始化依赖，启动 UI</td>
</tr>
<tr>
<td><strong>微服务</strong></td>
<td><code>Service</code> 启动类</td>
<td>连接数据库、启动 API</td>
</tr>
</tbody></table>
<p>无论是哪种类型的应用，<code>Main</code> 组件的核心职责始终是 <strong>组装组件，启动应用</strong>，而不是处理业务逻辑。</p>
<hr>
<h2 id="7-个人理解"><a href="#7-个人理解" class="headerlink" title="7. 个人理解"></a><strong>7. 个人理解</strong></h2><h3 id="1-Main-组件是一个“粘合剂”"><a href="#1-Main-组件是一个“粘合剂”" class="headerlink" title="1. Main 组件是一个“粘合剂”"></a><strong>1. Main 组件是一个“粘合剂”</strong></h3><p>Uncle Bob 的观点让我想到，<strong>Main 组件的真正作用是“粘合剂”</strong>：</p>
<ul>
<li>它把不同的组件组合在一起，但它本身并不参与业务逻辑的执行。</li>
<li>这样做的好处是，业务逻辑不会被 “Main” 组件污染，保持独立性和可测试性。</li>
</ul>
<h3 id="2-避免“胖-Main”"><a href="#2-避免“胖-Main”" class="headerlink" title="2. 避免“胖 Main”"></a><strong>2. 避免“胖 Main”</strong></h3><p>很多团队在实践中会把 <code>Main</code> 组件写得越来越复杂，包含大量配置逻辑、初始化逻辑，甚至业务逻辑。</p>
<ul>
<li><strong>正确的做法是保持 Main 的精简</strong>，可以把复杂的初始化逻辑拆分到 <strong>配置类（Configuration）</strong> 或 <strong>依赖注入框架（DI）</strong> 中。</li>
</ul>
<h3 id="3-现实项目中的最佳实践"><a href="#3-现实项目中的最佳实践" class="headerlink" title="3. 现实项目中的最佳实践"></a><strong>3. 现实项目中的最佳实践</strong></h3><ul>
<li><strong>如果使用 Spring Boot</strong>，尽量让 <code>@SpringBootApplication</code> 只负责启动，不要包含业务逻辑。</li>
<li><strong>如果使用微服务架构</strong>，让 <code>Main</code> 组件只负责 <code>API 路由</code> 和 <code>依赖注入</code>，业务逻辑放到 <code>Use Case</code> 层。</li>
<li><strong>如果是 Android/iOS 项目</strong>，尽量让 <code>Application</code> 只负责初始化，业务逻辑放到 <code>ViewModel</code> 或 <code>Use Case</code>。</li>
</ul>
<hr>
<h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a><strong>8. 结论</strong></h2><ul>
<li><strong>Main 组件是所有细节的汇聚点，但它本身应该尽可能简单</strong>。</li>
<li><strong>Main 组件应该依赖业务逻辑，而不是让业务逻辑依赖 Main</strong>。</li>
<li><strong>正确使用依赖注入（DI），避免 Main 组件变得过于复杂</strong>。</li>
</ul>
<p><strong>整洁架构的目标是让核心业务逻辑独立于技术细节，而 Main 组件只是组装和启动系统的入口，而不是核心！</strong> 🚀</p>
<h3 id="Services-Great-and-Small（服务：大与小）"><a href="#Services-Great-and-Small（服务：大与小）" class="headerlink" title="Services: Great and Small（服务：大与小）"></a>Services: Great and Small（服务：大与小）</h3><h1 id="第-27-章：Services-Great-and-Small（服务：大与小）"><a href="#第-27-章：Services-Great-and-Small（服务：大与小）" class="headerlink" title="第 27 章：Services: Great and Small（服务：大与小）"></a><strong>第 27 章：Services: Great and Small（服务：大与小）</strong></h1><p>在 <em>Clean Architecture</em> 的第 27 章，Uncle Bob 讨论了<strong>服务（Service）</strong> 在软件架构中的作用，并分析了如何合理地使用服务来划分系统，同时避免因滥用服务而导致架构复杂化的问题。</p>
<p>这一章的核心观点包括：</p>
<ol>
<li><strong>服务本质上是代码组织的一种方式</strong>，并不一定天然优于模块化架构。</li>
<li><strong>并不是所有功能都应该被拆分成服务</strong>，滥用服务可能会导致管理复杂度的上升。</li>
<li><strong>正确的服务划分应该基于架构需求，而不是盲目追求“微服务”或“SOA”</strong>。</li>
</ol>
<hr>
<h2 id="1-什么是“服务”？"><a href="#1-什么是“服务”？" class="headerlink" title="1. 什么是“服务”？"></a><strong>1. 什么是“服务”？</strong></h2><h3 id="服务的定义"><a href="#服务的定义" class="headerlink" title="服务的定义"></a><strong>服务的定义</strong></h3><p>在软件开发中，<strong>“服务”</strong>（Service）通常指的是：</p>
<ul>
<li><strong>一个封装了特定业务逻辑的独立组件</strong>，它可以通过 API 被调用。</li>
<li><strong>可以是本地方法、远程方法（RPC）、REST API、消息队列等</strong>。</li>
<li><strong>可以是单体架构（Monolithic）、微服务（Microservices）或面向服务架构（SOA）的一部分</strong>。</li>
</ul>
<h3 id="服务-vs-组件"><a href="#服务-vs-组件" class="headerlink" title="服务 vs. 组件"></a><strong>服务 vs. 组件</strong></h3><p>很多人会把 <strong>“服务”</strong> 和 <strong>“组件”</strong> 混为一谈，但它们的区别在于：</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>组件（Component）</strong></th>
<th><strong>服务（Service）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>运行环境</strong></td>
<td>进程内（In-Process）</td>
<td>进程外（Out-of-Process）</td>
</tr>
<tr>
<td><strong>调用方式</strong></td>
<td>直接方法调用</td>
<td>API / 网络请求（HTTP, gRPC, MQ）</td>
</tr>
<tr>
<td><strong>依赖关系</strong></td>
<td>直接依赖</td>
<td>通过 API 交互</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>低</td>
<td>高（涉及网络通信）</td>
</tr>
<tr>
<td><strong>独立部署</strong></td>
<td>通常依赖整体系统</td>
<td>可以单独部署</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-何时应该使用服务？"><a href="#2-何时应该使用服务？" class="headerlink" title="2. 何时应该使用服务？"></a><strong>2. 何时应该使用服务？</strong></h2><p>Uncle Bob 强调了一个重要原则：</p>
<blockquote>
<p><strong>如果代码在一个进程内运行并且可以被模块化良好地组织，就不需要拆分成服务。</strong></p>
</blockquote>
<p>许多团队 <strong>错误地认为“微服务”是现代架构的最佳选择</strong>，但实际上，<strong>拆分服务是有代价的</strong>：</p>
<ul>
<li><strong>增加运维成本</strong>（需要管理多个服务的部署、监控、日志）。</li>
<li><strong>增加通信开销</strong>（跨服务调用的性能远低于进程内调用）。</li>
<li><strong>增加数据一致性管理的难度</strong>（需要考虑分布式事务、幂等性等问题）。</li>
</ul>
<h3 id="什么时候应该拆分服务？"><a href="#什么时候应该拆分服务？" class="headerlink" title="什么时候应该拆分服务？"></a><strong>什么时候应该拆分服务？</strong></h3><p>在以下情况下，使用服务是合理的：</p>
<ol>
<li><strong>需要独立部署和扩展</strong>：<ul>
<li>例如，电商系统中的“支付服务”需要高可用，而“商品管理”可能不需要。</li>
<li><strong>拆分服务可以让关键业务独立扩展</strong>，提高系统的灵活性。</li>
</ul>
</li>
<li><strong>需要多种技术栈</strong>：<ul>
<li>如果某个业务模块需要使用特定的技术（如机器学习服务使用 Python，而订单系统使用 Java），那么拆分服务是合理的。</li>
</ul>
</li>
<li><strong>团队组织结构需要拆分</strong>：<ul>
<li>Conway’s Law（康威定律）指出：<strong>“系统的架构往往反映组织的沟通结构”</strong>。</li>
<li>如果不同的团队负责不同的业务领域，拆分服务可以让团队独立开发和维护。</li>
</ul>
</li>
<li><strong>需要跨系统复用</strong>：<ul>
<li>如果某个功能需要被多个系统复用（如用户认证服务），拆分成独立服务是合理的。</li>
</ul>
</li>
</ol>
<h3 id="什么时候不应该拆分服务？"><a href="#什么时候不应该拆分服务？" class="headerlink" title="什么时候不应该拆分服务？"></a><strong>什么时候不应该拆分服务？</strong></h3><p>如果满足以下条件，<strong>就不应该拆分服务</strong>：</p>
<ol>
<li><strong>业务逻辑紧密耦合，必须频繁交互</strong>：<ul>
<li>例如，一个“订单服务”如果必须在下单时调用“库存服务”、“支付服务”、“物流服务”，并且每个操作都需要实时反馈，那么拆分成多个服务可能会导致 <strong>过多的远程调用</strong>，降低系统性能。</li>
</ul>
</li>
<li><strong>只是为了“微服务”而拆分</strong>：<ul>
<li><strong>微服务不是目的，而是手段</strong>。如果一个小团队开发一个小型系统，却强行拆分成 10 个微服务，反而会增加管理复杂度。</li>
</ul>
</li>
<li><strong>单体架构已经能满足需求</strong>：<ul>
<li>如果系统体量不大，单体架构（Monolithic）其实更容易管理，例如：<ul>
<li>Rails/Django 的单体应用可以在一个进程内高效运行，维护成本低。</li>
<li>许多成功的产品（如 GitHub、Basecamp）都在相当长的时间内使用单体架构。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-微服务的挑战"><a href="#3-微服务的挑战" class="headerlink" title="3. 微服务的挑战"></a><strong>3. 微服务的挑战</strong></h2><p>Uncle Bob 指出，<strong>微服务架构带来的挑战远比许多人想象的要多</strong>，主要包括以下几个方面：</p>
<h3 id="1-远程调用的开销"><a href="#1-远程调用的开销" class="headerlink" title="1. 远程调用的开销"></a><strong>1. 远程调用的开销</strong></h3><ul>
<li><p>在单体架构中，调用一个方法只需要一次函数调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderService.placeOrder(order);</span><br></pre></td></tr></table></figure></li>
<li><p>但在微服务架构中，这个调用可能变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse response = httpClient.post(<span class="string">&quot;http://order-service/placeOrder&quot;</span>, order);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题 1</strong>：网络调用比进程内调用慢 <strong>1000 倍</strong> 以上。</li>
<li><strong>问题 2</strong>：如果 <code>order-service</code> 挂了，调用就会失败，需要考虑 <strong>重试、降级、熔断等机制</strong>。</li>
</ul>
</li>
</ul>
<h3 id="2-数据一致性"><a href="#2-数据一致性" class="headerlink" title="2. 数据一致性"></a><strong>2. 数据一致性</strong></h3><ul>
<li><p>在单体架构中，数据库事务可以保证一致性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (...) <span class="keyword">VALUES</span> (...);</span><br><span class="line">UPDATE inventory <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> product_id <span class="operator">=</span> ...;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>但在微服务架构中，这可能涉及多个数据库：</p>
<ol>
<li>订单服务插入 <code>orders</code> 表</li>
<li>库存服务更新 <code>inventory</code> 表</li>
<li>支付服务扣款</li>
</ol>
<ul>
<li><strong>问题 1</strong>：如果支付成功了，但库存更新失败了怎么办？</li>
<li><strong>问题 2</strong>：传统的数据库事务（ACID）无法跨多个微服务，只能使用 <strong>分布式事务（如 Saga）</strong>，但实现复杂。</li>
</ul>
</li>
</ul>
<h3 id="3-部署-amp-运维复杂度"><a href="#3-部署-amp-运维复杂度" class="headerlink" title="3. 部署 &amp; 运维复杂度"></a><strong>3. 部署 &amp; 运维复杂度</strong></h3><ul>
<li><p><strong>单体架构</strong>：一个 <code>war</code> 文件，部署到服务器上即可。</p>
</li>
<li><p>微服务架构</p>
<p>：需要：</p>
<ul>
<li><strong>服务发现（Service Discovery）</strong>：如 Consul、Eureka。</li>
<li><strong>负载均衡（Load Balancing）</strong>：如 Nginx、Envoy。</li>
<li><strong>日志 &amp; 监控（Logging &amp; Monitoring）</strong>：如 ELK、Prometheus。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-现实世界的权衡-1"><a href="#4-现实世界的权衡-1" class="headerlink" title="4. 现实世界的权衡"></a><strong>4. 现实世界的权衡</strong></h2><h3 id="案例-1：Netflix"><a href="#案例-1：Netflix" class="headerlink" title="案例 1：Netflix"></a><strong>案例 1：Netflix</strong></h3><ul>
<li>Netflix 使用微服务架构，但它有 <strong>上千名工程师</strong> 和 <strong>强大的 DevOps 团队</strong>，可以管理如此复杂的架构。</li>
<li>但如果一个 5 人团队模仿 Netflix 拆分 50 个微服务，那一定是灾难。</li>
</ul>
<h3 id="案例-2：GitHub"><a href="#案例-2：GitHub" class="headerlink" title="案例 2：GitHub"></a><strong>案例 2：GitHub</strong></h3><ul>
<li>GitHub 在很长一段时间内都是 <strong>单体架构</strong>（Monolith）。</li>
<li>直到业务复杂度增长到一定程度，他们才拆分出部分关键服务（如身份认证）。</li>
</ul>
<hr>
<h2 id="5-个人理解-5"><a href="#5-个人理解-5" class="headerlink" title="5. 个人理解"></a><strong>5. 个人理解</strong></h2><ul>
<li><strong>微服务 ≠ 好架构</strong>，单体架构在很多场景下更简单、高效。</li>
<li><strong>架构的选择应该基于业务需求，而不是技术潮流</strong>。</li>
<li><strong>避免“为了微服务而微服务”</strong>，否则可能会导致不必要的复杂性。</li>
<li><strong>如果必须拆分服务，应该优先考虑服务之间的边界和交互方式</strong>，避免过多的远程调用。</li>
</ul>
<hr>
<h2 id="6-结论-5"><a href="#6-结论-5" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h2><ul>
<li><strong>服务是一种工具，而不是架构的目标</strong>，不应该盲目拆分。</li>
<li><strong>在拆分服务之前，先考虑业务需求、团队规模和系统复杂度</strong>。</li>
<li><strong>如果单体架构已经能满足需求，不要轻易引入微服务，以免增加管理成本</strong>。</li>
<li><strong>微服务适用于大型企业，但小型团队更应该优先选择简单、易维护的架构</strong>。</li>
</ul>
<p>🚀 <strong>架构的目标是减少复杂性，而不是增加复杂性！</strong></p>
<h3 id="The-Test-Boundary（测试边界）"><a href="#The-Test-Boundary（测试边界）" class="headerlink" title="The Test Boundary（测试边界）"></a>The Test Boundary（测试边界）</h3><p>本章的核心观点包括：</p>
<ol>
<li><strong>测试也是架构的一部分，应该像业务代码一样被良好地组织和管理。</strong></li>
<li><strong>测试代码和生产代码之间应该有清晰的边界，确保测试不会影响系统的核心结构。</strong></li>
<li><strong>好的测试架构应该保证测试的稳定性、可读性和执行效率。</strong></li>
</ol>
<hr>
<h5 id="1-为什么测试边界很重要？"><a href="#1-为什么测试边界很重要？" class="headerlink" title="1. 为什么测试边界很重要？"></a><strong>1. 为什么测试边界很重要？</strong></h5><p>在软件开发中，测试通常被视为<strong>附属品</strong>，但 Uncle Bob 强调：</p>
<blockquote>
<p><strong>“如果没有测试，架构就无法确保长期的可维护性。”</strong></p>
</blockquote>
<h5 id="常见的测试问题"><a href="#常见的测试问题" class="headerlink" title="常见的测试问题"></a><strong>常见的测试问题</strong></h5><ol>
<li><strong>测试代码与业务逻辑紧密耦合</strong><ul>
<li>例如，测试直接访问数据库，导致每次重构数据库时，所有测试都需要修改。</li>
<li>解决方案：使用 <strong>测试替身（Test Doubles）</strong>，如 Mock、Stub、Fake 来隔离测试逻辑。</li>
</ul>
</li>
<li><strong>测试不稳定，容易失败</strong><ul>
<li>依赖外部系统（如数据库、API）的测试，可能因为网络波动或环境变化而失败。</li>
<li>解决方案：将测试分层，确保核心业务逻辑可以在 <strong>无依赖环境下独立运行</strong>。</li>
</ul>
</li>
<li><strong>测试执行速度慢，影响开发效率</strong><ul>
<li>端到端（E2E）测试通常运行时间长，导致开发者不愿意频繁执行测试。</li>
<li>解决方案：使用 <strong>金字塔测试策略</strong>，提高单元测试的比例。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-测试金字塔：不同层级的测试边界"><a href="#2-测试金字塔：不同层级的测试边界" class="headerlink" title="2. 测试金字塔：不同层级的测试边界"></a><strong>2. 测试金字塔：不同层级的测试边界</strong></h2><p>Uncle Bob 强调，在整洁架构中，我们应该 <strong>分层测试</strong>，确保测试既高效又可靠。</p>
<h3 id="测试金字塔（Test-Pyramid）"><a href="#测试金字塔（Test-Pyramid）" class="headerlink" title="测试金字塔（Test Pyramid）"></a><strong>测试金字塔（Test Pyramid）</strong></h3><p>测试金字塔是一种常见的测试策略，它将测试分为三类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  UI 测试（端到端测试）- 少量，运行慢</span><br><span class="line">│   UI Tests   │</span><br><span class="line">├──────────────┤  服务测试（集成测试）- 适量，验证组件交互</span><br><span class="line">│ Integration  │</span><br><span class="line">├──────────────┤  单元测试 - 最多，运行快，确保核心业务逻辑</span><br><span class="line">│  Unit Tests  │</span><br><span class="line">└──────────────┘  </span><br></pre></td></tr></table></figure>

<ul>
<li>单元测试（Unit Test）<ul>
<li>目标：测试单个模块或类的功能，隔离依赖。</li>
<li>例子：<code>OrderService</code> 是否正确计算订单总价？</li>
<li>运行速度快、易维护。</li>
</ul>
</li>
<li>集成测试（Integration Test）<ul>
<li>目标：测试多个组件的协作，比如 <code>OrderService</code> 和 <code>PaymentService</code> 是否能正确交互。</li>
<li>需要依赖数据库或 API，执行速度比单元测试慢。</li>
</ul>
</li>
<li>UI 测试 / 端到端测试（E2E Test）<ul>
<li>目标：模拟真实用户操作，验证整个系统的正确性。</li>
<li>例子：用户从登录到下单的整个流程是否正常？</li>
<li>运行时间最长，通常使用 Selenium、Cypress 进行自动化测试。</li>
</ul>
</li>
</ul>
<h3 id="推荐的测试比例"><a href="#推荐的测试比例" class="headerlink" title="推荐的测试比例"></a><strong>推荐的测试比例</strong></h3><ul>
<li>70% 单元测试</li>
<li>20% 集成测试</li>
<li>10% UI / 端到端测试</li>
</ul>
<hr>
<h2 id="3-如何定义测试边界？"><a href="#3-如何定义测试边界？" class="headerlink" title="3. 如何定义测试边界？"></a><strong>3. 如何定义测试边界？</strong></h2><h3 id="测试与代码架构的关系"><a href="#测试与代码架构的关系" class="headerlink" title="测试与代码架构的关系"></a><strong>测试与代码架构的关系</strong></h3><p>整洁架构中的测试应该遵循 <strong>“测试与业务逻辑解耦”</strong> 的原则，避免测试代码影响核心架构。</p>
<h4 id="（1）测试核心业务逻辑（Use-Cases）"><a href="#（1）测试核心业务逻辑（Use-Cases）" class="headerlink" title="（1）测试核心业务逻辑（Use Cases）"></a><strong>（1）测试核心业务逻辑（Use Cases）</strong></h4><p>在整洁架构中，业务逻辑通常封装在 <strong>用例（Use Case）</strong> 中。</p>
<ul>
<li><strong>好的做法</strong>：只测试业务逻辑，而不测试具体实现。</li>
<li><strong>不好的做法</strong>：测试某个具体框架（如 Spring Controller）内部细节，导致测试代码与实现代码紧密耦合。</li>
</ul>
<p><strong>示例：正确的单元测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderUseCaseTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlaceOrderSuccessfully</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OrderRepository mockOrderRepo = mock(OrderRepository.class);</span><br><span class="line">        PaymentService mockPaymentService = mock(PaymentService.class);</span><br><span class="line">        when(mockPaymentService.charge(any())).thenReturn(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        PlaceOrderUseCase placeOrderUseCase = <span class="keyword">new</span> PlaceOrderUseCase(mockOrderRepo, mockPaymentService);</span><br><span class="line">        Order order = <span class="keyword">new</span> Order(<span class="string">&quot;123&quot;</span>, List.of(<span class="keyword">new</span> Item(<span class="string">&quot;item1&quot;</span>, <span class="number">100</span>)));</span><br><span class="line"></span><br><span class="line">        placeOrderUseCase.execute(order);</span><br><span class="line"></span><br><span class="line">        verify(mockOrderRepo).save(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ <strong>优点</strong>：</p>
<ul>
<li><strong>完全隔离业务逻辑</strong>，不依赖数据库或 Web 框架。</li>
<li><strong>测试速度快，可独立执行</strong>。</li>
</ul>
<hr>
<h4 id="（2）测试基础设施层（Infrastructure）"><a href="#（2）测试基础设施层（Infrastructure）" class="headerlink" title="（2）测试基础设施层（Infrastructure）"></a><strong>（2）测试基础设施层（Infrastructure）</strong></h4><ul>
<li>适用于数据库访问、API 调用等场景。</li>
<li>由于数据库连接等依赖变化较多，通常使用 <strong>集成测试</strong> 来保证其正确性。</li>
</ul>
<p><strong>示例：数据库测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">new</span> Order(<span class="string">&quot;123&quot;</span>, List.of(<span class="keyword">new</span> Item(<span class="string">&quot;item1&quot;</span>, <span class="number">100</span>)));</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        Optional&lt;Order&gt; savedOrder = orderRepository.findById(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        assertTrue(savedOrder.isPresent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）测试-API-层（Web-Controllers"><a href="#（3）测试-API-层（Web-Controllers" class="headerlink" title="*（3）测试 API 层（Web Controllers"></a>*（3）测试 API 层（Web Controllers</h4><p>Web 层通常通过 <code>REST API</code> 提供数据，因此可以使用 <strong>集成测试</strong> 来验证其行为。</p>
<p><strong>示例：Spring Boot API 测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest(OrderController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> PlaceOrderUseCase placeOrderUseCase;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateOrder</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(post(<span class="string">&quot;/orders&quot;</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .content(<span class="string">&quot;&#123;\&quot;orderId\&quot;: \&quot;123\&quot;, \&quot;items\&quot;: [&#123;\&quot;name\&quot;: \&quot;item1\&quot;, \&quot;price\&quot;: 100&#125;]&#125;&quot;</span>))</span><br><span class="line">            .andExpect(status().isOk());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-测试的现实世界挑战"><a href="#4-测试的现实世界挑战" class="headerlink" title="4. 测试的现实世界挑战"></a><strong>4. 测试的现实世界挑战</strong></h2><h3 id="1-如何避免“测试即负担”"><a href="#1-如何避免“测试即负担”" class="headerlink" title="1. 如何避免“测试即负担”"></a><strong>1. 如何避免“测试即负担”</strong></h3><ul>
<li><p>许多团队写了大量测试，但发现每次修改代码时，<strong>测试也要改</strong>，增加了维护成本。</p>
</li>
<li><p>解决方案</p>
<p>：</p>
<ul>
<li><strong>测试业务逻辑，而不是实现细节</strong>。</li>
<li>避免对框架（如 Spring）内部机制的测试。</li>
</ul>
</li>
</ul>
<h3 id="2-如何保证-CI-CD-运行高效"><a href="#2-如何保证-CI-CD-运行高效" class="headerlink" title="2. 如何保证 CI/CD 运行高效"></a><strong>2. 如何保证 CI/CD 运行高效</strong></h3><ul>
<li><p>由于 UI 测试执行速度慢，整个 CI/CD 过程可能变得很慢。</p>
</li>
<li><p>解决方案</p>
<p>：</p>
<ul>
<li>只在 PR（Pull Request）合并前运行 UI 测试，而在日常开发时只运行单元测试。</li>
</ul>
</li>
</ul>
<h3 id="3-如何处理遗留系统"><a href="#3-如何处理遗留系统" class="headerlink" title="3. 如何处理遗留系统"></a><strong>3. 如何处理遗留系统</strong></h3><ul>
<li>许多企业的遗留系统 <strong>没有测试</strong>，但直接重构风险太高。</li>
<li>解决方案:逐步引入 <strong>契约测试（Contract Testing）</strong>，确保 API 兼容性。</li>
</ul>
<h2 id="6-结论-6"><a href="#6-结论-6" class="headerlink" title="6. 结论"></a><strong>6. 结论</strong></h2><ul>
<li><strong>测试代码和业务逻辑应该有清晰的边界，避免相互干扰。</strong></li>
<li><strong>遵循测试金字塔策略，优先编写快速、稳定的单元测试。</strong></li>
<li><strong>好的测试架构应该降低维护成本，而不是增加负担。</strong></li>
</ul>
<p>🚀 <strong>测试是架构的一部分，只有良好的测试策略，才能让架构真正“整洁”！</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"># 技术</a>
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/03/16/leadership/" rel="prev" title="什么是领导力">
      <i class="fa fa-chevron-left"></i> 什么是领导力
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/03/18/distribution-transaction/" rel="next" title="分布式事务技术二十年发展">
      分布式事务技术二十年发展 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">什么是架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="nav-number">1.0.1.</span> <span class="nav-text">传统的误解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.0.2.</span> <span class="nav-text">正确的定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83%E7%9B%AE%E6%A0%87"><span class="nav-number">1.1.</span> <span class="nav-text">架构的核心目标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E6%98%AF%E5%85%B3%E4%BA%8E%E2%80%9C%E4%BF%9D%E6%8C%81%E9%80%89%E9%A1%B9%E5%BC%80%E6%94%BE%E2%80%9D%EF%BC%88Keeping-Options-Open%EF%BC%89"><span class="nav-number">1.1.1.</span> <span class="nav-text">架构是关于“保持选项开放”（Keeping Options Open）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E5%BA%94%E8%AF%A5%E2%80%9C%E6%8E%A8%E8%BF%9F%E6%8A%80%E6%9C%AF%E5%86%B3%E7%AD%96%E2%80%9D"><span class="nav-number">1.1.2.</span> <span class="nav-text">架构应该“推迟技术决策”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E6%98%AF%E5%85%B3%E4%BA%8E%E2%80%9C%E5%88%86%E7%A6%BB%E5%85%B3%E6%B3%A8%E7%82%B9%E2%80%9D%EF%BC%88Separation-of-Concerns%EF%BC%89"><span class="nav-number">1.1.3.</span> <span class="nav-text">架构是关于“分离关注点”（Separation of Concerns）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84-vs-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.</span> <span class="nav-text">架构 vs. 详细设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%9E%B6%E6%9E%84%E5%86%B3%E7%AD%96"><span class="nav-number">1.3.</span> <span class="nav-text">现实世界的架构决策</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1%EF%BC%9A%E9%94%99%E8%AF%AF%E7%9A%84%E6%9E%B6%E6%9E%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.3.1.</span> <span class="nav-text">案例 1：错误的架构选择</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">独立性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B9%88%E6%98%AF%E2%80%9C%E7%8B%AC%E7%AB%8B%E6%80%A7%E2%80%9D%EF%BC%9F"><span class="nav-number">2.0.1.</span> <span class="nav-text">么是“独立性”？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%BE%9D%E8%B5%96"><span class="nav-number">3.</span> <span class="nav-text">常见的软件依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8B%AC%E7%AB%8B%E6%80%A7%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">3.0.1.</span> <span class="nav-text">2. 为什么独立性重要？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%AE%A9%E8%BD%AF%E4%BB%B6%E6%9B%B4%E5%AE%B9%E6%98%93%E4%BF%AE%E6%94%B9"><span class="nav-number">4.</span> <span class="nav-text">（1）让软件更容易修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8F%90%E9%AB%98%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">（2）提高可测试性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%81%BF%E5%85%8D%E6%8A%80%E6%9C%AF%E9%94%81%E5%AE%9A%EF%BC%88Vendor-Lock-in%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">（3）避免技术锁定（Vendor Lock-in）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E2%80%9C%E7%8B%AC%E7%AB%8B%E6%80%A7%E2%80%9D%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">3. 如何实现“独立性”？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%8B%AC%E7%AB%8B%E4%BA%8E%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">（1）独立于框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%8B%AC%E7%AB%8B%E4%BA%8E-UI"><span class="nav-number">2.</span> <span class="nav-text">（2）独立于 UI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">4. 个人理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">边界——如何划分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E8%BE%B9%E7%95%8C%E2%80%9D%EF%BC%9F"><span class="nav-number">1.0.1.</span> <span class="nav-text">** 什么是“边界”？**</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E7%B1%BB%E6%AF%94"><span class="nav-number">2.</span> <span class="nav-text">现实世界的类比</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%B9%E7%95%8C%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">2.0.1.</span> <span class="nav-text">为什么边界重要？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8F%90%E9%AB%98%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">（1）提高可维护性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8F%90%E9%AB%98%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7-1"><span class="nav-number">4.</span> <span class="nav-text">（2）提高可测试性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%8F%90%E9%AB%98%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-number">5.</span> <span class="nav-text">（3）提高灵活性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E8%BE%B9%E7%95%8C%EF%BC%9F"><span class="nav-number">5.0.1.</span> <span class="nav-text">如何划分边界？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E4%BA%8E%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E5%88%92%E5%88%86"><span class="nav-number">6.</span> <span class="nav-text">（1）基于业务功能划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%9F%BA%E4%BA%8E%E6%8A%80%E6%9C%AF%E5%B1%82%E5%88%92%E5%88%86"><span class="nav-number">7.</span> <span class="nav-text">（2）基于技术层划分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">5. 个人理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E2%80%9C%E8%BE%B9%E7%95%8C%E2%80%9D-%E2%89%A0-%E2%80%9C%E7%89%A9%E7%90%86%E6%8B%86%E5%88%86%E2%80%9D"><span class="nav-number">1.</span> <span class="nav-text">1. “边界” ≠ “物理拆分”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E2%80%9C%E9%94%99%E8%AF%AF%E7%9A%84%E8%BE%B9%E7%95%8C%E6%AF%94%E6%B2%A1%E6%9C%89%E8%BE%B9%E7%95%8C%E6%9B%B4%E7%B3%9F%E7%B3%95%E2%80%9D"><span class="nav-number">2.</span> <span class="nav-text">2. “错误的边界比没有边界更糟糕”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E7%9A%84%E8%A7%A3%E5%89%96"><span class="nav-number">3.</span> <span class="nav-text">边界的解剖</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-18-%E7%AB%A0%EF%BC%9ABoundaries-Anatomy%EF%BC%88%E8%BE%B9%E7%95%8C%E7%9A%84%E8%A7%A3%E5%89%96%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">第 18 章：Boundaries: Anatomy（边界的解剖）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%B9%E7%95%8C%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 为什么边界重要？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E7%B1%BB%E6%AF%94-1"><span class="nav-number">1.</span> <span class="nav-text">现实世界的类比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BD%AF%E4%BB%B6%E4%B8%AD%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="nav-number"></span> <span class="nav-text">2. 软件中的边界</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%9E%B6%E6%9E%84%E5%B1%82%E7%BA%A7%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="nav-number">1.</span> <span class="nav-text">（1）架构层级的边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%BF%9B%E7%A8%8B%E8%BE%B9%E7%95%8C"><span class="nav-number">2.</span> <span class="nav-text">（2）进程边界</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E7%BA%BF%E7%A8%8B%E8%BE%B9%E7%95%8C"><span class="nav-number">3.</span> <span class="nav-text">（3）线程边界</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E8%BE%B9%E7%95%8C%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">3. 代码中的边界模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%EF%BC%88Dependency-Inversion%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">（1）依赖倒置（Dependency Inversion）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88Adapter-Pattern%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">（2）适配器模式（Adapter Pattern）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E4%B8%8E%E5%B1%82%E6%AC%A1"><span class="nav-number">3.</span> <span class="nav-text">策略与层次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E7%AD%96%E7%95%A5%E2%80%9D"><span class="nav-number"></span> <span class="nav-text">1. 什么是“策略”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%B5%E5%95%86%E8%AE%A2%E5%8D%95%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">示例：电商订单系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%B1%82%E6%AC%A1%E2%80%9D%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">2. 什么是“层次”？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%A2%E5%8D%95%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="nav-number">1.</span> <span class="nav-text">示例：订单管理系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BE%9D%E8%B5%96%E6%96%B9%E5%90%91%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE"><span class="nav-number"></span> <span class="nav-text">3. 依赖方向与依赖倒置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">错误的架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">正确的架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number"></span> <span class="nav-text">4. 现实世界的案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1%EF%BC%9AAmazon"><span class="nav-number">1.</span> <span class="nav-text">案例 1：Amazon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-2%EF%BC%9ANetflix"><span class="nav-number">2.</span> <span class="nav-text">案例 2：Netflix</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3-1"><span class="nav-number"></span> <span class="nav-text">5. 个人理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E2%80%9C%E7%AD%96%E7%95%A5%E2%80%9D-%E6%98%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="nav-number">1.</span> <span class="nav-text">1. “策略” 是架构的核心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E2%80%9C%E5%B1%82%E6%AC%A1%E2%80%9D-%E5%86%B3%E5%AE%9A%E4%BA%86%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">2. “层次” 决定了代码的可维护性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA"><span class="nav-number"></span> <span class="nav-text">6. 结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99"><span class="nav-number">1.</span> <span class="nav-text">业务规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-20-%E7%AB%A0%EF%BC%9ABusiness-Rules%EF%BC%88%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">第 20 章：Business Rules（业务规则）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 什么是业务规则？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">业务规则的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99-vs-%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">业务规则 vs. 业务流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number"></span> <span class="nav-text">2. 业务规则的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">3. 如何在代码中实现业务规则？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AE%9E%E4%BD%93%E5%B1%82%EF%BC%9A%E5%B0%81%E8%A3%85%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99"><span class="nav-number">1.</span> <span class="nav-text">（1）实体层：封装企业级业务规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%94%A8%E4%BE%8B%E5%B1%82%EF%BC%9A%E5%B0%81%E8%A3%85%E5%BA%94%E7%94%A8%E7%BA%A7%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">（2）用例层：封装应用级业务规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C-Web-%E5%B1%82%EF%BC%9A%E4%B8%8D%E5%8C%85%E5%90%AB%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99"><span class="nav-number">3.</span> <span class="nav-text">（3）数据库和 Web 层：不包含业务规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%A9%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E7%8B%AC%E7%AB%8B%E4%BA%8E%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">4. 为什么要让业务规则独立于技术？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8F%90%E9%AB%98%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7-1"><span class="nav-number">1.</span> <span class="nav-text">（1）提高可维护性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8F%90%E9%AB%98%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7-2"><span class="nav-number">2.</span> <span class="nav-text">（2）提高可测试性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number"></span> <span class="nav-text">5. 现实世界的案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1%EF%BC%9AAmazon-1"><span class="nav-number">1.</span> <span class="nav-text">案例 1：Amazon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-2%EF%BC%9A%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">案例 2：银行系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA-1"><span class="nav-number"></span> <span class="nav-text">6. 结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E5%BA%94%E8%AF%A5%E5%A4%A7%E5%A3%B0%E2%80%9C%E5%91%BC%E5%96%8A%E2%80%9D%E5%AE%83%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">1.</span> <span class="nav-text">架构应该大声“呼喊”它的目标</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-21-%E7%AB%A0%EF%BC%9AScreaming-Architecture%EF%BC%88%E6%9E%B6%E6%9E%84%E5%BA%94%E8%AF%A5%E5%A4%A7%E5%A3%B0%E2%80%9C%E5%91%BC%E5%96%8A%E2%80%9D%E5%AE%83%E7%9A%84%E7%9B%AE%E6%A0%87%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">第 21 章：Screaming Architecture（架构应该大声“呼喊”它的目标）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E6%9E%B6%E6%9E%84%E5%9C%A8%E5%91%BC%E5%96%8A%E4%BB%80%E4%B9%88%E2%80%9D%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 什么是“架构在呼喊什么”？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84-Web-%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.</span> <span class="nav-text">示例：一个典型的 Web 项目</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B%EF%BC%89%E6%8A%80%E6%9C%AF%E5%AF%BC%E5%90%91%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">（错误示例）技术导向的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E6%AD%A3%E7%A1%AE%E7%A4%BA%E4%BE%8B%EF%BC%89%E4%B8%9A%E5%8A%A1%E5%AF%BC%E5%90%91%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">（正确示例）业务导向的架构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%9E%B6%E6%9E%84%E5%9C%A8%E2%80%9C%E5%91%BC%E5%96%8A%E6%8A%80%E6%9C%AF%E2%80%9D%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">2. 为什么大多数架构在“呼喊技术”？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%B5%81%E8%A1%8C%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">1.</span> <span class="nav-text">（1）流行框架的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">（2）数据库驱动的架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E8%AE%A9%E6%9E%B6%E6%9E%84%E2%80%9C%E5%91%BC%E5%96%8A%E2%80%9D%E4%B8%9A%E5%8A%A1%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">3. 如何让架构“呼喊”业务？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8C%89%E4%B8%9A%E5%8A%A1%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8C%89%E6%8A%80%E6%9C%AF"><span class="nav-number">1.</span> <span class="nav-text">（1）按业务组织代码，而不是按技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BD%BF%E7%94%A8%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">（2）使用整洁架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%8E%A8%E8%BF%9F%E6%8A%80%E6%9C%AF%E5%86%B3%E7%AD%96"><span class="nav-number">3.</span> <span class="nav-text">（3）推迟技术决策</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%A1%88%E4%BE%8B-1"><span class="nav-number"></span> <span class="nav-text">4. 现实世界的案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1%EF%BC%9AAmazon-2"><span class="nav-number">1.</span> <span class="nav-text">案例 1：Amazon</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-2%EF%BC%9ANetflix-1"><span class="nav-number">2.</span> <span class="nav-text">案例 2：Netflix</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3-2"><span class="nav-number"></span> <span class="nav-text">5. 个人理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E2%80%9C%E6%A1%86%E6%9E%B6%E6%98%AF%E7%BB%86%E8%8A%82%EF%BC%8C%E4%B8%9A%E5%8A%A1%E6%89%8D%E6%98%AF%E6%A0%B8%E5%BF%83%E2%80%9D"><span class="nav-number">1.</span> <span class="nav-text">1. “框架是细节，业务才是核心”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E2%80%9C%E6%8C%89%E4%B8%9A%E5%8A%A1%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8C%89%E6%8A%80%E6%9C%AF%E2%80%9D"><span class="nav-number">2.</span> <span class="nav-text">2. “按业务组织代码，而不是按技术”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E2%80%9C%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%BA%94%E8%AF%A5%E7%8B%AC%E7%AB%8B%E4%BA%8E%E6%8A%80%E6%9C%AF%E6%A0%88%E2%80%9D"><span class="nav-number">3.</span> <span class="nav-text">3. “业务逻辑应该独立于技术栈”</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA-2"><span class="nav-number">3.0.1.</span> <span class="nav-text">6. 结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">整洁架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-22-The-Clean-Architecture%EF%BC%88%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">Chapter 22: The Clean Architecture（整洁架构）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 什么是整洁架构？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E7%9A%84%E5%90%8C%E5%BF%83%E5%9C%86%E6%A8%A1%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">2. 整洁架构的同心圆模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E4%BD%93%EF%BC%88Entities%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">(1) 实体（Entities）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%94%A8%E4%BE%8B%EF%BC%88Use-Cases%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">(2) 用例（Use Cases）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88Interface-Adapters%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">(3) 接口适配器（Interface Adapters）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%A1%86%E6%9E%B6-amp-%E9%A9%B1%E5%8A%A8%EF%BC%88Frameworks-amp-Drivers%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">(4) 框架 &amp; 驱动（Frameworks &amp; Drivers）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BE%9D%E8%B5%96%E8%A7%84%E5%88%99%EF%BC%88The-Dependency-Rule%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">3. 依赖规则（The Dependency Rule）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B8%E5%9E%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number"></span> <span class="nav-text">4. 整洁架构的典型示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number"></span> <span class="nav-text">5. 整洁架构与其他架构的比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84-vs-MVC"><span class="nav-number">1.</span> <span class="nav-text">整洁架构 vs. MVC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%9D%E8%80%83"><span class="nav-number"></span> <span class="nav-text">6. 个人理解与思考</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E7%BB%93%E8%AE%BA"><span class="nav-number">0.0.1.</span> <span class="nav-text">7. 结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-23-Presenters-and-Humble-Objects%EF%BC%88%E5%B1%95%E7%8E%B0%E5%99%A8%E4%B8%8E%E8%B0%A6%E5%8D%91%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">Chapter 23: Presenters and Humble Objects（展现器与谦卑对象）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87"><span class="nav-number"></span> <span class="nav-text">1. 主要目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B1%95%E7%8E%B0%E5%99%A8%EF%BC%88Presenters%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">2. 展现器（Presenters）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%95%E7%8E%B0%E5%99%A8%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是展现器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%95%E7%8E%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">展现器的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Presenter-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">3.</span> <span class="nav-text">Presenter 的优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%B0%A6%E5%8D%91%E5%AF%B9%E8%B1%A1%EF%BC%88Humble-Objects%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">3. 谦卑对象（Humble Objects）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B0%A6%E5%8D%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是谦卑对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B0%A6%E5%8D%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">为什么需要谦卑对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%A6%E5%8D%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%81%9A%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">谦卑对象的做法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%87%8D%E6%9E%84-UI-%E9%80%BB%E8%BE%91"><span class="nav-number">3.1.</span> <span class="nav-text">示例：重构 UI 逻辑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Presenter-amp-Humble-Object-%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number"></span> <span class="nav-text">4. Presenter &amp; Humble Object 的结合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3-3"><span class="nav-number"></span> <span class="nav-text">5. 个人理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Presenter-%E5%9C%A8%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">1. Presenter 在实际项目中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%B0%A6%E5%8D%91%E5%AF%B9%E8%B1%A1%E9%80%82%E7%94%A8%E4%BA%8E%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">2. 谦卑对象适用于哪些场景？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA-3"><span class="nav-number">2.0.1.</span> <span class="nav-text">6. 结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partial-Boundaries%EF%BC%88%E9%83%A8%E5%88%86%E8%BE%B9%E7%95%8C%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">Partial Boundaries（部分边界）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%83%A8%E5%88%86%E8%BE%B9%E7%95%8C%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 什么是部分边界？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E9%83%A8%E5%88%86%E8%BE%B9%E7%95%8C%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么时候应该使用部分边界？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B7%B3%E8%BF%87%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5%EF%BC%88Skip-the-Last-Step%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">2. 跳过最后一步（Skip the Last Step）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%80%9D%E6%83%B3"><span class="nav-number">2.</span> <span class="nav-text">关键思想</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%80%E7%BB%B4%E8%BE%B9%E7%95%8C%EF%BC%88One-Dimensional-Boundaries%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">3. 一维边界（One-Dimensional Boundaries）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%80%9D%E6%83%B3-1"><span class="nav-number">2.</span> <span class="nav-text">关键思想</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%EF%BC%88Facades%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">4. 外观模式（Facades）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">1.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3-4"><span class="nav-number"></span> <span class="nav-text">5. 个人理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E2%80%9C%E9%83%A8%E5%88%86%E8%BE%B9%E7%95%8C%E2%80%9D-vs-%E2%80%9C%E8%BF%87%E5%BA%A6%E6%8A%BD%E8%B1%A1%E2%80%9D"><span class="nav-number">1.</span> <span class="nav-text">1. “部分边界” vs. “过度抽象”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E2%80%9C%E9%83%A8%E5%88%86%E8%BE%B9%E7%95%8C%E2%80%9D-vs-%E2%80%9C%E6%8A%80%E6%9C%AF%E5%80%BA%E5%8A%A1%E2%80%9D"><span class="nav-number">2.</span> <span class="nav-text">2. “部分边界” vs. “技术债务”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">3. 适用于什么场景？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA-4"><span class="nav-number"></span> <span class="nav-text">6. 结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Layers-and-Boundaries%EF%BC%88%E5%B1%82%E4%B8%8E%E8%BE%B9%E7%95%8C%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">Layers and Boundaries（层与边界）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B1%82%E5%92%8C%E8%BE%B9%E7%95%8C%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 为什么要使用层和边界？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%85%B8%E5%9E%8B%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%88%86%E5%B1%82"><span class="nav-number"></span> <span class="nav-text">2. 典型的软件分层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AE%9E%E4%BD%93%E5%B1%82%EF%BC%88Entities%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">（1）实体层（Entities）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%94%A8%E4%BE%8B%E5%B1%82%EF%BC%88Use-Cases-Application-Layer%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">（2）用例层（Use Cases &#x2F; Application Layer）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E5%B1%82%EF%BC%88Interface-Adapters%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">（3）接口适配层（Interface Adapters）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%A1%86%E6%9E%B6-amp-%E9%A9%B1%E5%8A%A8%E5%B1%82%EF%BC%88Frameworks-amp-Drivers%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">（4）框架 &amp; 驱动层（Frameworks &amp; Drivers）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BE%9D%E8%B5%96%E6%96%B9%E5%90%91"><span class="nav-number"></span> <span class="nav-text">3. 依赖方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="nav-number"></span> <span class="nav-text">4. 现实世界的权衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BB%93%E8%AE%BA"><span class="nav-number"></span> <span class="nav-text">5. 结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Main-Component%EF%BC%88%E4%B8%BB%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">The Main Component（主组件）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-26-%E7%AB%A0%EF%BC%9AThe-Main-Component%EF%BC%88%E4%B8%BB%E7%BB%84%E4%BB%B6%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">第 26 章：The Main Component（主组件）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E4%B8%BB%E7%BB%84%E4%BB%B6%E2%80%9D%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 什么是“主组件”？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Main-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%81%8C%E8%B4%A3"><span class="nav-number"></span> <span class="nav-text">2. Main 组件的正确职责</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%EF%BC%9AMain-%E4%BE%9D%E8%B5%96%E4%B8%9A%E5%8A%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8F%8D%E8%BF%87%E6%9D%A5"><span class="nav-number"></span> <span class="nav-text">3. 依赖倒置：Main 依赖业务，而不是反过来</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%85%B8%E5%9E%8B%E7%9A%84-Main-%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number"></span> <span class="nav-text">4. 典型的 Main 组件实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">不推荐的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">推荐的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Main-%E7%BB%84%E4%BB%B6%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">5. Main 组件与依赖注入（DI）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Main-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8E%B0%E5%AE%9E%E5%BA%94%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">6. Main 组件的现实应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="nav-number"></span> <span class="nav-text">7. 个人理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Main-%E7%BB%84%E4%BB%B6%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9C%E7%B2%98%E5%90%88%E5%89%82%E2%80%9D"><span class="nav-number">1.</span> <span class="nav-text">1. Main 组件是一个“粘合剂”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%81%BF%E5%85%8D%E2%80%9C%E8%83%96-Main%E2%80%9D"><span class="nav-number">2.</span> <span class="nav-text">2. 避免“胖 Main”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%8E%B0%E5%AE%9E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.</span> <span class="nav-text">3. 现实项目中的最佳实践</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BB%93%E8%AE%BA"><span class="nav-number"></span> <span class="nav-text">8. 结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Services-Great-and-Small%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%A4%A7%E4%B8%8E%E5%B0%8F%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">Services: Great and Small（服务：大与小）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC-27-%E7%AB%A0%EF%BC%9AServices-Great-and-Small%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%9A%E5%A4%A7%E4%B8%8E%E5%B0%8F%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">第 27 章：Services: Great and Small（服务：大与小）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E6%9C%8D%E5%8A%A1%E2%80%9D%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">1. 什么是“服务”？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">服务的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1-vs-%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">服务 vs. 组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BD%95%E6%97%B6%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">2. 何时应该使用服务？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E6%8B%86%E5%88%86%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么时候应该拆分服务？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E5%BA%94%E8%AF%A5%E6%8B%86%E5%88%86%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">什么时候不应该拆分服务？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-number"></span> <span class="nav-text">3. 微服务的挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E5%BC%80%E9%94%80"><span class="nav-number">1.</span> <span class="nav-text">1. 远程调用的开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">2. 数据一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%83%A8%E7%BD%B2-amp-%E8%BF%90%E7%BB%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text">3. 部署 &amp; 运维复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E6%9D%83%E8%A1%A1-1"><span class="nav-number"></span> <span class="nav-text">4. 现实世界的权衡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1%EF%BC%9ANetflix"><span class="nav-number">1.</span> <span class="nav-text">案例 1：Netflix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-2%EF%BC%9AGitHub"><span class="nav-number">2.</span> <span class="nav-text">案例 2：GitHub</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3-5"><span class="nav-number"></span> <span class="nav-text">5. 个人理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA-5"><span class="nav-number"></span> <span class="nav-text">6. 结论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Test-Boundary%EF%BC%88%E6%B5%8B%E8%AF%95%E8%BE%B9%E7%95%8C%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">The Test Boundary（测试边界）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%8B%E8%AF%95%E8%BE%B9%E7%95%8C%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="nav-number">1.0.1.</span> <span class="nav-text">1. 为什么测试边界很重要？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8B%E8%AF%95%E9%97%AE%E9%A2%98"><span class="nav-number">1.0.2.</span> <span class="nav-text">常见的测试问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%B1%82%E7%BA%A7%E7%9A%84%E6%B5%8B%E8%AF%95%E8%BE%B9%E7%95%8C"><span class="nav-number"></span> <span class="nav-text">2. 测试金字塔：不同层级的测试边界</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E9%87%91%E5%AD%97%E5%A1%94%EF%BC%88Test-Pyramid%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">测试金字塔（Test Pyramid）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E6%B5%8B%E8%AF%95%E6%AF%94%E4%BE%8B"><span class="nav-number">2.</span> <span class="nav-text">推荐的测试比例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%B5%8B%E8%AF%95%E8%BE%B9%E7%95%8C%EF%BC%9F"><span class="nav-number"></span> <span class="nav-text">3. 如何定义测试边界？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.</span> <span class="nav-text">测试与代码架构的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%B5%8B%E8%AF%95%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%EF%BC%88Use-Cases%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">（1）测试核心业务逻辑（Use Cases）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%B1%82%EF%BC%88Infrastructure%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">（2）测试基础设施层（Infrastructure）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%B5%8B%E8%AF%95-API-%E5%B1%82%EF%BC%88Web-Controllers"><span class="nav-number">1.3.</span> <span class="nav-text">*（3）测试 API 层（Web Controllers</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%B5%8B%E8%AF%95%E7%9A%84%E7%8E%B0%E5%AE%9E%E4%B8%96%E7%95%8C%E6%8C%91%E6%88%98"><span class="nav-number"></span> <span class="nav-text">4. 测试的现实世界挑战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E2%80%9C%E6%B5%8B%E8%AF%95%E5%8D%B3%E8%B4%9F%E6%8B%85%E2%80%9D"><span class="nav-number">1.</span> <span class="nav-text">1. 如何避免“测试即负担”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-CI-CD-%E8%BF%90%E8%A1%8C%E9%AB%98%E6%95%88"><span class="nav-number">2.</span> <span class="nav-text">2. 如何保证 CI&#x2F;CD 运行高效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">3. 如何处理遗留系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BB%93%E8%AE%BA-6"><span class="nav-number"></span> <span class="nav-text">6. 结论</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">爱妙妙爱生活</p>
  <div class="site-description" itemprop="description">日拱一卒，功不唐捐</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">221</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/samz406" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;samz406" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lilin@apache.org" title="E-Mail → mailto:lilin@apache.org" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">蜀ICP备2021016919号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">爱妙妙爱生活</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
